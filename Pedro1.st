PackageManifest subclass: #ManifestPedro1	instanceVariableNames: ''	classVariableNames: ''	package: 'Pedro1-Manifest'!!ManifestPedro1 commentStamp: '<historical>' prior: 0!Please describe the package using the class comment of the included manifest class. The manifest class also includes other additional metadata for the package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ManifestPedro1 class	instanceVariableNames: ''!!ManifestPedro1 class methodsFor: 'code-critics' stamp: 'PeterGraf 2/1/2024 22:04'!ruleCollectionMessagesToExternalObjectRuleV1FalsePositive	<ignoreForCoverage>	^ #(#(#(#RGPackageDefinition #(#Pedro1)) #'2024-02-01T22:04:55.603218+01:00') )! !!ManifestPedro1 class methodsFor: 'code-critics' stamp: 'PeterGraf 2/1/2024 15:41'!ruleUnclassifiedMethodsRuleV1FalsePositive	<ignoreForCoverage>	^ #(#(#(#RGPackageDefinition #(#Pedro1)) #'2024-02-01T15:41:46.982706+01:00') )! !!ManifestPedro1 class methodsFor: 'code-critics' stamp: 'PeterGraf 2/20/2024 13:20'!ruleStringConcatenationRuleV1FalsePositive	<ignoreForCoverage>	^ #(#(#(#RGMetaclassDefinition #(#'ETileBigRoassal class' #ETileBigRoassal)) #'2024-02-20T13:20:57.750133+01:00') )! !!ManifestPedro1 class methodsFor: 'code-critics' stamp: 'PeterGraf 2/6/2024 12:32'!ruleWhileTrueRuleV1FalsePositive	<ignoreForCoverage>	^ #(#(#(#RGClassDefinition #(#ETileBigRoassal)) #'2024-02-01T15:32:36.699498+01:00') )! !!ManifestPedro1 class methodsFor: 'code-critics' stamp: 'PeterGraf 2/2/2024 23:44'!ruleCollectionProtocolRuleV1FalsePositive	<ignoreForCoverage>	^ #(#(#(#RGPackageDefinition #(#Pedro1)) #'2024-02-02T23:44:05.54509+01:00') )! !!ManifestPedro1 class methodsFor: 'code-critics' stamp: 'PeterGraf 2/20/2024 11:25'!ruleToDoCollectRuleV1FalsePositive	<ignoreForCoverage>	^ #(#(#(#RGMetaclassDefinition #(#'BigETileRoassal class' #ETileBigRoassal)) #'2024-02-04T14:40:17.636344+01:00') #(#(#RGMethodDefinition #(#ETileBigRoassal #buildAllStrands #false)) #'2024-02-15T12:30:10.94401+01:00') #(#(#RGMethodDefinition #(#ETilesCount2x2 #convertIndexToTuple: #false)) #'2024-02-18T12:18:07.473556+01:00') #(#(#RGClassDefinition #(#ETilesCount2x2)) #'2024-02-18T12:28:33.378175+01:00') #(#(#RGClassDefinition #(#ETilesCount3x3)) #'2024-02-19T12:39:52.189533+01:00') #(#(#RGClassDefinition #(#ETilesCount2x2b)) #'2024-02-20T11:25:53.273047+01:00') )! !!ManifestPedro1 class methodsFor: 'code-critics' stamp: 'PeterGraf 2/19/2024 09:15'!ruleCodeCruftLeftInMethodsRuleV1FalsePositive	<ignoreForCoverage>	^ #(#(#(#RGClassDefinition #(#ETilesCount2x2)) #'2024-02-19T09:15:14.975511+01:00') )! !!ManifestPedro1 class methodsFor: 'code-critics' stamp: 'PeterGraf 2/6/2024 12:32'!ruleUnaryAccessingMethodWithoutReturnRuleV1FalsePositive	<ignoreForCoverage>	^ #(#(#(#RGClassDefinition #(#ETileBigRoassal)) #'2024-02-03T18:16:55.876275+01:00') )! !!ManifestPedro1 class methodsFor: 'code-critics' stamp: 'PeterGraf 2/6/2024 12:32'!ruleToDoWithIncrementRuleV1FalsePositive	<ignoreForCoverage>	^ #(#(#(#RGMetaclassDefinition #(#'BigETileRoassal class' #ETileBigRoassal)) #'2024-02-04T14:40:24.225003+01:00') )! !!ManifestPedro1 class methodsFor: 'code-critics' stamp: 'PeterGraf 3/6/2024 13:50'!ruleModifiesCollectionRuleV1FalsePositive	<ignoreForCoverage>	^ #(#(#(#RGMethodDefinition #(#ETileBigRoassal #paintMouseClickRightEventsForPolygonsOn: #false)) #'2024-02-03T00:16:53.353636+01:00') #(#(#RGClassDefinition #(#ETileBigRoassal)) #'2024-03-06T13:50:55.129526+01:00') )! !!ManifestPedro1 class methodsFor: 'code-critics' stamp: 'PeterGraf 2/19/2024 12:53'!ruleReGuardClauseRuleV1FalsePositive	<ignoreForCoverage>	^ #(#(#(#RGClassDefinition #(#ETileBigRoassal)) #'2024-02-03T18:16:46.835347+01:00') #(#(#RGClassDefinition #(#ETilesCount2x2)) #'2024-02-19T09:15:56.038914+01:00') #(#(#RGClassDefinition #(#ETilesCount3x3)) #'2024-02-19T12:53:46.616481+01:00') )! !!ManifestPedro1 class methodsFor: 'code-critics' stamp: 'PeterGraf 2/19/2024 12:53'!ruleGuardingClauseRuleV1FalsePositive	<ignoreForCoverage>	^ #(#(#(#RGClassDefinition #(#ETileBigRoassal)) #'2024-02-03T18:17:04.359249+01:00') #(#(#RGClassDefinition #(#ETilesCount2x2)) #'2024-02-19T09:15:51.873699+01:00') #(#(#RGClassDefinition #(#ETilesCount3x3)) #'2024-02-19T12:53:39.621886+01:00') )! !FileList subclass: #ETileApp	instanceVariableNames: 'fileLocator'	classVariableNames: ''	package: 'Pedro1'!!ETileApp commentStamp: 'PeterGraf 2/25/2024 11:46' prior: 0!ETileApp PeterThe ETileApp is a file browser.A selected file is opened in a new window by pressing the open button.The editor always takes its input from a filename and the file''s content.The filename describes one of 154 possible Escher Tiles.The user can interactivly assign colors to the strands and alterthe weaving of the tiles.The current state could be stored in a new file or exported as a PDF.What is a tile?A tile is a rectangle where the colors at the edges matcheach other on top and on bottom, and on the left and on the right.The editor takes care of this rule.The editor additionally doesn't allow to color crossing different strands with the same color.What is a strand?A strand is a sequence of polygons that are connected.Due to the tile property each polygon having an edge atthe border of the big tile is connected to the polygonat the opposite side of the rectangle. A basic Escher Tile is a square with five polygons inside.The picture shows four basic Escher Tiles (tile (1x1)) with the four possible weavings 'abcd'.The polygons inside a title (1x1) are labeled with 1..5.The weaving of a tile (1x1) describes the possible crossingof its polygons 1, 4 and 5.Stan Wagon used different names for the weaving:' ' for 'a''a' for 'b''rr' for 'c''rl' for 'd'A tile (1x1) can be rotated left and optionally finally flipped horizontally. These eight operations on a tile (1x1) are named:'+1' no rotation'+2' rotate left 90°'+3' rotate left 180°'+4' rotate left 270°'-1' no rotation, flip'-2' rotate left 90°, flip'-3' rotate left 180°, flip'-4' rotate left 270°, flipStan Wagon used ' ' instead of '+'.These operations don't affect the weaving of a tile (1x1).M.C. Escher always grouped four tiles (1x1) together in a square.I call such a group a tile (2x2).There exist 8 * 8 * 8 * 8 = 4096 possible tiles (2x2).  But it turned out that there are just 154 different tiles (2x2).All other tiles (2x2) are similiar to one of these.Source: Stan Wagon, ? Davis, and me.Class ETilesCount2x2 counts the possible pattern for tiles (2x2).The runtime is two seconds.Transcript shows the list of patterns with the indices "1" to "154"together with the index of the survivors out of the 4096.If a 'rotate left 90°' is done on a tile (2x2) each tile (1x1) gets a new positionin the tile (2x2): 1 2 3 4  -->  2 4 1 3.But each tile (1x1) rotated too, i.e.: '+1'  -->  '+2'.The 154 tiles (2x2) are labeled with '001'..'154'.But I use the order introduced by Stan Wagon.That makes it easier to work with both sources.Class ETileCount3x3 counts the possible patterns for tiles (3x3).The runtime is about 15 minutes (Intel ix5).There are 934144 survivors in the about 140 million candidates.And of course there is no list shown in Transcript.You can think of a tile (1x1) as a real rubber stamp.Because of the flip operator you will need each rubber stamp twice.And concerning the four possible weavings you will end upwith eight rubber stamps.Equipped like that you would be able to manufacture any of the 154 patterns.If you take just one tile (2x2) you will find outthat they look rather dull when it comes to coloring.It's because most of them allow just one color.Stan Wagon offers a list of minimal numbers of tiles (2x2)to build a reasonable colorable bigger tile.His list specifies rectangles for each of the 154 tiles (2x2).I use this list by default.The editor opens on a given filename that describes thenecessary parameters:'nnn'['Ttttt']['Wwwww']['Drrcc']['Frfcf']['P...']'.txt'nnn				'001'..'154' Index of a tile (2x2) 					mandatoryTtttt			t = '+1'|'+2'|'+3'|'+4'|'-1'|'-2'|'-3'|'-4'					optional					is info only					default: from table (Stan Wagon)Wwwww 			w = 'a'|'b'|'c'|'d'					weavings for a tile (2x2)					optional					default: from tableDrrcc		 	rr = '02'..'99', number of rows					cc = '02'..'99', number of columns					optional					default: rr, cc from table (Stan Wagon)Frfcf		 	rf = '01'..'99', rows factor					cf = '01'..'99', columns factor					optional					default: '01', '01'P...				options, up to ' (' or '.' in the filename,					optional					default: all of them false							Show in the export filename					't'	show the pattern for the tile (2x2)					'w'	show the weaving of the tile (2x2)					'd'	show the dimension of the big tile							Borders in the editor					'b'	paint a big frame					'i'	paint a frame for each tile (1x1)					'l'	paint the polygons with borders							Actions					'f'	color all uncolored polygons, use few colors					'm'	color all uncolored polygons, use many colors					'p'  export as PDF and close windowThe filename specifies what I want to edit and some actions.The 'nnn' part and the extension '.txt' are mandatory.All other parts are optional as described above.'Frfcf' will be explained later.The whole rectangle that you see in the editor is called the big tile.Select a color in the palette.The selected color is shown in a circle.Assign the selected color to a strand with a left Mouseclick.Alter the weaving in any tile (2x2) by pushing a polygon below the other polygons witha right Mouseclick. This will also change the weaving in the correspondingtiles (2x2) of the big tile.Where are the colors of a big tile?It's the content of the file.Please don't change the content.The content of the file represents the colors of the polygons.This specific content refers also to the dimension of the exported big tile (txt).Starting the editor with the exported file will show you the same big tile again.In case you changed the dimension ('D') in this filename, the content would not suitto the new dimension. Opening the editor will show you a mess of colors in the big file.Simply 'Clear' the colors and choose 'AutoColor'.But there is a way to repeat the colors of the smaller big tile in a larger one.Suppose you have exported (txt) a well colored big tile having the dimension 'D0203'.To get a bigger shaped big tile with dimension 'D0809' you need to inserta 'F0403' part into the filename.Now open the editor on this renamed file.The entry 'D0203F0403' in the filename will result in a big tile of 'D0809'.And of course the colors are properly copied to the other tiles.Warning: The copying into the new tiles is done directly from polygon to polygon. This bypasses the rule that crossing different strands cannot be colored with the same color. example hereETileApp Window'Filter': A text the filename has to start withOpenNewRenameCopyDeleteAfter the file export from the editor the new file isn't visible in the list of file.To refresh the view on the filenames press 'Enter' in the Filter.File handlingETileApp offers only minimal file handling.Please use the filebrowser of your os. Good news: The editor never overwrites a file.To cope with equal filenames I use the behavior that I know from my chromebook.In case of a conflict the new filename is extended by adding a ' (n)' to the basename of the filename.'n' is the next possible number.When renaming a file I always try to get rid of the ' (n)'.You need not delete ' (n)' manually.'Copy' is a speciality.It copies a file in the same directory and gives it a new name.Especially before doing 'Rename' I myself do a 'Copy' and rename the copied file.ExportPDFThe pdf contains the canvas with the big tile without the color palette and the menue.Therefore the big tile looks like being surrounded by a broad white margin.I used an online sevice to delete the white margin in a pdf file.Keywords for internet: pdf white margin crop!!ETileApp methodsFor: 'private' stamp: 'PeterGraf 2/23/2024 18:54'!filesMatching: aPattern""	"Answer a list of directory entries which match the patternString."	| files |	files :=  [self directory files] on:DirectoryDoesNotExist do:[#()].	aPattern ifNil:[^files].	^ files select: [:entry | entry basename includesSubstring: aPattern at: 1]"	aRegex := aPattern asRegex.	^ files select: [:entry | (aRegex search: entry basename)]"! !!ETileApp methodsFor: 'private' stamp: 'PeterGraf 2/23/2024 18:53'!filesMatchingBackup: aPattern""	"Answer a list of directory entries which match the patternString."	| files |	files :=  [self directory files] on:DirectoryDoesNotExist do:[#()].	aPattern ifNil:[^files].	^ files select: [:entry | entry basename includesSubstring: aPattern]"	aRegex := aPattern asRegex.	^ files select: [:entry | (aRegex search: entry basename)]"! !!ETileApp methodsFor: 'private' stamp: 'PeterGraf 2/12/2024 12:55'!sortBlockTimestamp	"Answer block to decide what order to display the directory entries."	^ [ :x :y | |xIsDir|			((xIsDir := x isDirectory) = y isDirectory)				ifTrue: [   x modificationTime  >= y modificationTime ]				ifFalse: [					"directories always precede files"					xIsDir ]]! !!ETileApp methodsFor: 'private' stamp: 'PeterGraf 2/14/2024 13:50'!put: aText	^ true.	! !!ETileApp methodsFor: 'private' stamp: 'PeterGraf 2/12/2024 21:13'!defaultContents	^	''! !!ETileApp methodsFor: 'file list menu' stamp: 'PeterGraf 3/2/2024 09:48'!itemsForETileFile"context menü"	"Answer a list of services that could apply to an etile file"	| services |	services := OrderedCollection new: 7.	services add: self serviceRefreshFilelist.	services add: self serviceOpenETileFromFile.	services add: self serviceRenameFile.	services add: self serviceAddNewFile.	services add: self serviceCopyAndInsertFile.	"services add: self serviceCopyName."	services add: self serviceDeleteFile.	^ services! !!ETileApp methodsFor: 'file list menu' stamp: 'PeterGraf 2/14/2024 11:38'!itemsForFile: file	"Answer a list of services appropriate for a file"	"^ (self class itemsForFile: file)"		^	self itemsForETileFile! !!ETileApp methodsFor: 'file list menu' stamp: 'PeterGraf 3/2/2024 11:33'!fileSelectedMenu: aMenu	| services |	services := OrderedCollection new: 10.	"services := OrderedCollection withAll: (self itemsForFile: reference)."	"n1 := services size."	services addAll: self itemsForETileFile.	^ aMenu		addServices: services		for: self		extraLines: #()"	n2 := services size.	services addAll: self itemsForNoFile.	n3 := services size.	services := services collect: [ :svc | svc copy.].	services do: [ :svc | svc addDependent: self; doNotUseLineAfter ].	^ aMenu		addServices: services		for: self		extraLines: (Array with: n1 with: n2 with: n3)"		! !!ETileApp methodsFor: 'file list menu' stamp: 'PeterGraf 2/14/2024 13:46'!itemsForDirectory: dir	^	OrderedCollection new		"	| services |		services := OrderedCollection new.	dir ifNotNil: [	services		addAll: (self class itemsForDirectory: dir).		services ifNotEmpty: [services last useLineAfter] ].	services add: self serviceAddNewFile.	services add: self serviceAddNewDirectory.	services addAll: self configuredServices.	^ services"! !!ETileApp methodsFor: 'file list menu' stamp: 'PeterGraf 3/2/2024 11:55'!itemsForNoFile 	| services |	"self fileListIndex: 0.	reference := reference parent.	self updateFileList.	brevityState := #FileList.	self get."		services := OrderedCollection new.	services add: self serviceAddNewFile.	"services addAll: (self itemsForDirectory: (self isFileSelected ifFalse: [ self directory ] ifTrue: []))."	^ services		"	| services |	services := OrderedCollection new.	services addAll: (self itemsForDirectory: (self isFileSelected ifFalse: [ self directory ] ifTrue: [])).	^ services"! !!ETileApp methodsFor: 'own services' stamp: 'PeterGraf 3/2/2024 11:59'!serviceCopyAndInsertFile	^ (SimpleServiceEntry		provider: self		label: 'Copy'		selector: #addCopyFile		description: 'Copy renamed file and insert here' )		! !!ETileApp methodsFor: 'own services' stamp: 'PeterGraf 3/2/2024 11:41'!serviceAddNewFile	"Answer a service entry characterizing the 'add new file' command"	^(SimpleServiceEntry		provider: self		label: 'New'		selector: #addNewFile		description: 'Create a new empty file.')		usingLineAfter: false! !!ETileApp methodsFor: 'own services' stamp: 'PeterGraf 2/14/2024 13:30'!serviceOpenETileFromFile	^ (SimpleServiceEntry		provider: self		label: 'Open'		selector: #openETileFromFile		description: 'Start ETile editor')! !!ETileApp methodsFor: 'own services' stamp: 'PeterGraf 3/2/2024 11:40'!serviceAddNewDirectoryBackup	"Answer a service entry characterizing the 'add new directory' command"	^ SimpleServiceEntry		provider: self		label: 'No new directory'		selector: #addNewDirectory		description: 'Adds a new, empty directory (folder)'		"	^ SimpleServiceEntry		provider: self		label: 'Add new directory'		selector: #addNewDirectory		description: 'Adds a new, empty directory (folder)'	"! !!ETileApp methodsFor: 'own services' stamp: 'PeterGraf 3/2/2024 09:46'!serviceRefreshFilelist	"Answer a service entry characterizing the 'Refresh' command"	^(SimpleServiceEntry		provider: self		label: 'Refresh'		selector: #updateFileList		description: 'Refresh the file list.')		usingLineAfter: false! !!ETileApp methodsFor: 'updating' stamp: 'PeterGraf 3/2/2024 11:17'!changedContentsBackup	"self sourceTextModel setText: self contents"! !!ETileApp methodsFor: 'user interface' stamp: 'PeterGraf 2/14/2024 15:33'!morphicPatternPane	"Remove the vertical scrollbar since the minHeight would otherwise	be too large to fit the layout frame. Added here for Pharo since	FileList2 has been merged into FileList."	^ SearchMorph new		model: self;		setIndexSelector: #pattern:;		getIndexSelector: #pattern;		searchList: self class searchList;		vResizing: #spaceFill;		hResizing: #rigid; "Filter bleibt dadurch gleich breit"		yourself! !!ETileApp methodsFor: 'user interface' stamp: 'PeterGraf 2/12/2024 03:14'!morphicGrid	grid := ETileFileListGrid new		parent: self.	grid		onSelectionChangeSend: #findFileListIndex: to: self ;		menu: #fileListMenu  shifted: false.	^ grid treeMorph! !!ETileApp methodsFor: 'initialization' stamp: 'PeterGraf 2/14/2024 14:41'!optionalButtonRow	"Answer the button row associated with a file list"	| aRow |	aRow := AlignmentMorph newRow beSticky.	aRow color: Color transparent.	aRow clipSubmorphs: true.	aRow layoutInset: 0@0; cellInset: 6.	aRow setNameTo: 'buttons'.	aRow setProperty: #buttonRow toValue: true.  "Used for dynamic retrieval later on"	^ aRow! !!ETileApp methodsFor: 'initialization' stamp: 'PeterGraf 2/11/2024 16:42'!initialize	super initialize.		baseLabel := 'ETilesApp Dir: '.		(FileLocator home / 'eTiles') ensureCreateDirectory.	self selectedDirectory: (FileLocator home / 'eTiles') asFileReference.! !!ETileApp methodsFor: 'accessing' stamp: 'PeterGraf 2/12/2024 00:00'!contents	"Answer the contents of the file, reading it first if needed."	"Possible brevityState values:		FileList,		fullFile, briefFile, needToGetFull, needToGetBrief,		fullHex, briefHex, needToGetFullHex, needToGetBriefHex"	^	''! !!ETileApp methodsFor: 'morphic ui' stamp: 'PeterGraf 2/14/2024 15:33'!morphicViewOnFile: aFile	| window fileListBottom midLine fileListTopOffset buttonPane fileContentsView |	window := (SystemWindow labelled: self labelString) model: self.	fileListTopOffset := TextStyle defaultFont pointSize * 2 + 11.	fileListBottom := 1.0 . "horizontale Linie unter filelist "	midLine := 0.26 . "senkrechte Linie zwischen Tree und filelist"	buttonPane := self optionalButtonRow addMorph: self morphicPatternPane.	self		addFullPanesTo: window		from:			{{self morphicDirectoryTreePane.			(LayoutFrame identity rightFraction: midLine )}.			{buttonPane.			(LayoutFrame identity leftFraction: midLine ; bottomFraction: 0 ; bottomOffset: fileListTopOffset - 3)}.			{self morphicFileListPane.			(LayoutFrame identity leftFraction: midLine ; bottomFraction: fileListBottom ; topOffset: fileListTopOffset)}."			{(fileContentsView := self morphicFileContentsPane).			(LayoutFrame identity leftFraction: midLine ; topFraction: fileListBottom)}."			}.	contents		ifNotNil: [ fileContentsView setText: contents asText.			fileContentsView hasUnacceptedEdits: true ].	self postOpen.	^ window! !!ETileApp methodsFor: 'file menu action' stamp: 'PeterGraf 2/16/2024 17:48'!renameFile	"Rename the currently selected file"	"Kriegt immer die Extension '.txt'"	"Überschreibt nicht"	| newName response |	listIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	(response := UIManager default request: 'NewFileName?' translated 		initialAnswer: reference basename)		isEmptyOrNil ifTrue: [^ self].	newName := response asFileName.	"newName = reference basename ifTrue: [^ self]."	newName := self generateUniqueFileName: newName.	reference renameTo: newName.	self updateFileList.	listIndex := list findFirst: [:item | item = newName].	listIndex > 0		ifTrue: [reference := newName].	self changed: #fileListIndex! !!ETileApp methodsFor: 'file menu action' stamp: 'PeterGraf 2/14/2024 16:21'!addNewFile	self directory isWritable ifFalse: [ ^ self ].	self directory isReadable ifFalse: [ ^ self ].		self		addNew: '001Pwdbl.txt'		byEvaluating: [:newName | (self directory / (self generateUniqueFileName: newName)) ensureCreateFile ]			! !!ETileApp methodsFor: 'file menu action' stamp: 'PeterGraf 2/12/2024 21:13'!deleteFile""	"Delete the currently selected file"	listIndex = 0 ifTrue: [^ self].		reference delete.	reference := reference parent.	self updateFileList.	brevityState := #FileList.	self get! !!ETileApp methodsFor: 'file menu action' stamp: 'PeterGraf 3/2/2024 11:22'!get	"Get contents of file again, it may have changed. Do this by making the cancel string be the contents, and doing a cancel."		^	nil		"	Cursor read		showWhile: [			self okToChange				ifFalse: [ ^ nil ].			brevityState := brevityState == #briefHex				ifTrue: [ #needToGetFullHex ]				ifFalse: [ #needToGetFull ].			self changedContents			 ]"! !!ETileApp methodsFor: 'file menu action' stamp: 'PeterGraf 3/2/2024 11:59'!addCopyFile	listIndex = 0 ifTrue: [^ self].	reference copyTo: ( reference parent / (self generateUniqueFileName: reference basename) ). 		self updateFileList.	self updateDirectory.! !!ETileApp methodsFor: 'file menu action' stamp: 'PeterGraf 2/14/2024 14:03'!openETileFromFile	listIndex = 0 ifTrue: [ ^ self ].	ETileBigRoassal newFromFileName: reference basename fileLocator: reference parent.! !!ETileApp methodsFor: 'file menu action' stamp: 'PeterGraf 3/2/2024 11:15'!addNew: aString byEvaluating: aBlock	"A parameterization of earlier versions of #addNewDirectory and	#addNewFile.  Fixes the bug in each that pushing the cancel button	in the FillInTheBlank dialog gave a walkback."	| response newName index |	self okToChange ifFalse: [^ self].	(response := UIManager default						request: ('Starting with 001..154?' translated format: {aString translated})						initialAnswer: ('{1}' translated format: {aString translated}))		isEmptyOrNil ifTrue: [^ self].	newName := response asFileName.	Cursor wait showWhile: [		aBlock value: newName].	self updateFileList.	self updateDirectory.	list ifNotNil:[		index := list indexOf: newName.		index = 0 ifTrue: [			index := list findFirst: [:line | line basename endsWith: newName]].		self fileListIndex: index.]! !!ETileApp methodsFor: 'file menu action' stamp: 'PeterGraf 2/11/2024 17:00'!generateUniqueFileName: aFileNameString| fNameWithoutExtension fNameExtensionWithPoint posOfPoint num temp |	self directory ifNil: [ ^ aFileNameString ].	fNameWithoutExtension := aFileNameString copyUpToSubstring: '.'.	fNameWithoutExtension := fNameWithoutExtension copyUpToSubstring: ' ('.	"	Answer the file extension of the given file	^ aName		ifNil: ['']		ifNotNil: [  aName asFileReference extension asLowercase]"		posOfPoint :=  aFileNameString findLastOccurrenceOfString: '.' startingAt: 1.	fNameExtensionWithPoint :=		posOfPoint isZero 			ifTrue: [ '' ] 			ifFalse: [ 				fNameExtensionWithPoint := aFileNameString copyFrom: posOfPoint to: aFileNameString size.			].	num := 0.	temp := fNameWithoutExtension.	[ (self directory / (temp, fNameExtensionWithPoint)) exists ] whileTrue: [		num := num + 1.		temp := String streamContents: [ :stream | "Umbennennung wie am chromebook"			            stream				            nextPutAll: fNameWithoutExtension;				            space;				            nextPut: $(;				            nextPutAll: num asString;				            nextPut: $) ] ].	^ temp, fNameExtensionWithPoint.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ETileApp class	instanceVariableNames: ''!!ETileApp class methodsFor: 'utilities' stamp: 'PeterGraf 2/14/2024 11:35'!itemsForFile: file	"Answer a list of services appropriate for a file of the given full name"	^ OrderedCollection new: 1.	"^ FileServices itemsForFile: file fullName"! !!ETileApp class methodsFor: 'utilities' stamp: 'PeterGraf 2/14/2024 11:35'!itemsForDirectory: aFileDirectory	"Answer a list of services appropriate when no file is selected."	^ OrderedCollection new: 1.	"^ FileServices itemsForDirectory: aFileDirectory"! !!ETileApp class methodsFor: 'running' stamp: 'PeterGraf 2/14/2024 14:23'!run	| win |	win := ETileApp open.	win position: 960 @ 0.! !Object subclass: #ETileBigRoassal	instanceVariableNames: 'theIndex allTiles rows columns minRows minColumns colorPalette canvas curColorIndex curColorIndexBefore numberOfStrands lineDict options60 fileLocator allStrands strandsColorIndices strandsRegistered strandCrossingsSet fourPattern3 tileColorIndices2D'	classVariableNames: 'FourPatternStrings154 Todo'	package: 'Pedro1'!!ETileBigRoassal commentStamp: 'PeterGraf 2/23/2024 12:52' prior: 0!Mehrere ETileRoassal in einem Rechteck anordnen, so dass das Rechteck eine Fliese ist.Die kleinste denkbare Anordnung ist 2x2, beschrieben durch 4 Patterns.Diese werden so wiederholt, dass das BigETile ausgefüllt ist.Bei einer Fliese sind die Farbübergänge sowohl oben und unten, als auch links und rechts, gleich.Dazu eine Tabelle aus 'Mathematica in Action', Stan Wagon.curFlexiblePattern beschreibt ein BigETile.rows := minRows * rowFactorcolumns := minColumns * columnFactorcolorStrandsarray mit colorIndices der strandslineDictkey: eine sortierte Roassal-Linievalue: alle Polygone (2, OrderedCollection new: 2), die diese Roassal-Linie als Randlinie haben.strandCrossingsset der sich kreuzenden Polynome, paarweise.!!ETileBigRoassal methodsFor: 'testing' stamp: 'PeterGraf 2/20/2024 12:32'!isWithLoopStrandIndexTodo: aStrandIndex"Der strand ist länger als 6."Todo.	^	false! !!ETileBigRoassal methodsFor: 'testing' stamp: 'PeterGraf 2/20/2024 00:06'!hasSelfCrossingStrand	1 to: allStrands size do: [ :i | 		(self isSelfCrossingStrandIndex: i) ifTrue: [ ^	true ]].			^	false! !!ETileBigRoassal methodsFor: 'testing' stamp: 'PeterGraf 2/20/2024 12:29'!isWithTwoDeadEndsStrandIndexTodo: aStrandIndex"Der strand mindestens die Länge 8."Todo.	^	false! !!ETileBigRoassal methodsFor: 'testing' stamp: 'PeterGraf 2/20/2024 12:29'!isWithOneDeadEndStrandIndexTodo: aStrandIndex"Ein dead end besteht aus drei Polygonen 2 oder 3, undeinem Polygon 1 oder 5.Diese vier Polygone liegen in vier verschiedenen tiles.Die Länge des strand ist grösser 4."Todo.	^	false! !!ETileBigRoassal methodsFor: 'testing' stamp: 'PeterGraf 2/15/2024 20:02'!isDiamondStrandIndexOkButOld: aStrandIndex" Diamond Eigenschaften- Besteht nur aus den Polygonen 2 und 3.- Hat die Länge 4. - Kommt in strandCrossings nicht vor."	^	strandCrossingsSet detect: [ :e | e first = aStrandIndex ]			ifFound: [ ^ false ]			ifNone:  [ ^ true ]! !!ETileBigRoassal methodsFor: 'testing' stamp: 'PeterGraf 2/16/2024 10:35'!isDiamondStrandIndex: aStrandIndex" Diamond Eigenschaften- Besteht nur aus den Polygonen 2 und 3.- Hat die Länge 4. - Kommt in strandCrossings nicht vor."	^	(allStrands at: aStrandIndex) detect: [ :polygon |			#(1 4 5) includes: polygon polygonIndex ]				ifFound: [ ^ false ]				ifNone:  [ ^ true ]! !!ETileBigRoassal methodsFor: 'testing' stamp: 'PeterGraf 2/15/2024 20:35'!isSelfCrossingStrandIndex: aStrandIndex"strand enthält mindestens 2x die Polygone 1, 4 oder 5 im gleichen tile."	| polygone145 set145 |		polygone145 := 			(allStrands at: aStrandIndex) select: [ :polygon |			#(1 4 5) includes: polygon polygonIndex ].	set145 := 			(polygone145 collect: [ :polygon | polygon eTile ]) asSet.	^	polygone145 size > set145 size! !!ETileBigRoassal methodsFor: 'testing' stamp: 'PeterGraf 3/9/2024 10:19'!isShortStrandIndex: aStrandIndex"Short strands sind relativ frei färbbar. ""Diamanten sind keine short strands."	"check for freie Bändchen"	"((allStrands at: aStrandIndex) size = 9) ifTrue: [^	true ].	"	"check for kites"	((allStrands at: aStrandIndex) size = 6) ifTrue: [^	true ].		^	((allStrands at: aStrandIndex) size = 4) "squares"		and: [ (self isDiamondStrandIndex: aStrandIndex) not]! !!ETileBigRoassal methodsFor: 'testing' stamp: 'PeterGraf 2/20/2024 12:21'!isWithMoreDeadEndsStrandIndexTodo: aStrandIndex"schwer"Todo.	^	false! !!ETileBigRoassal methodsFor: 'testing' stamp: 'PeterGraf 2/20/2024 00:06'!hasDiamond	1 to: allStrands size do: [ :i | 		(self isDiamondStrandIndex: i) ifTrue: [ ^	true ]].			^	false! !!ETileBigRoassal methodsFor: 'testing' stamp: 'PeterGraf 2/20/2024 12:18'!hasShortStrand	1 to: allStrands size do: [ :i | 		(self isShortStrandIndex: i) ifTrue: [ ^	true ]].			^	false! !!ETileBigRoassal methodsFor: 'initialization' stamp: 'PeterGraf 3/9/2024 19:22'!initialize 	super initialize.	self theIndex: 1. "nicht direkt ändern"	"Alles auf false."	options60 := 0.		colorPalette := ETileColorPalette new mixed35.	curColorIndex := 1.	curColorIndexBefore := curColorIndex.	strandsRegistered := OrderedCollection new.		"LineDict := Dictionary new."	lineDict := Dictionary new.! !!ETileBigRoassal methodsFor: 'initialization' stamp: 'PeterGraf 2/13/2024 09:24'!mirrorColorIndicesAtBorderBackup"Ohne Prüfung"		self lineDict keysDo: [ :key | | value |				value := self lineDict at: key.				value size = 1 ifTrue: [ "nur ein Polygon eingetragen"			| polygon |			polygon := value first.			polygon colorIndex ifNotNil: [ 				(key first x = key second x) 					ifTrue: [ 						"vertical line"						(	self lineDict at: 							{ key first x negated @ key first y . key second x negated @ key second y } sorted						) first updateRSPolygonColorIndex: polygon colorIndex											] ifFalse: [ 						"horizontal line"						(	self lineDict at: 								{ key first x @ key first y negated . key second x @ key second y negated } sorted						) first updateRSPolygonColorIndex: polygon colorIndex					].				]]]! !!ETileBigRoassal methodsFor: 'private' stamp: 'PeterGraf 2/4/2024 01:30'!optionSet: bitIndex		"1..60"	(bitIndex <= 60) ifTrue: [		options60 := options60 bitOr: (1 bitShift: bitIndex - 1)	].! !!ETileBigRoassal methodsFor: 'private' stamp: 'PeterGraf 2/1/2024 12:22'!optionIsSet: bitIndex		"1..60"	(bitIndex > 60) ifTrue: [ ^ false ].	^	( options60 bitAnd: (1 bitShift: bitIndex - 1) ) ~= 0! !!ETileBigRoassal methodsFor: 'private' stamp: 'PeterGraf 2/1/2024 12:11'!optionReset: bitIndex		"1..60"	(bitIndex <= 60) ifTrue: [		options60 := options60 bitAnd: ( SmallInteger maxVal - (1 bitShift: bitIndex - 1) )	]! !!ETileBigRoassal methodsFor: 'building' stamp: 'PeterGraf 2/29/2024 08:41'!spreadPattern"Erzeugt die ETileRoassal im allTiles mit dem richtigen pattern3, z.B. '+1a'""rowRaster * columnRaster Raster"	| yRow1 xColumn1 rowRaster columnRaster |		rowRaster := 2.	columnRaster := 2.	"center of Point at: 1 at: 1"	xColumn1 := 50 - (columns*50).	yRow1 := 50 - (rows*50).	"Das richtige pattern3 aus fourPatterns3 über die rows und columns von allTiles verteilen."	1 to: rows do: [ :rowInd |		1 to: columns do: [ :columnInd | | eTileRoassal |			eTileRoassal := ETileRoassal newFromPattern3:				( fourPattern3 at: 					(columnInd-1) % columnRaster + 1 + (columnRaster * ( (rowInd-1) % rowRaster) ) ).			eTileRoassal 				bigETile: self;				row: rowInd; 				column: columnInd;				centerPoint: ( (columnInd-1)*100 + xColumn1 ) @ ( (rowInd-1)*100 + yRow1 ).			allTiles at: rowInd at: columnInd put: eTileRoassal ]]! !!ETileBigRoassal methodsFor: 'building' stamp: 'PeterGraf 2/15/2024 12:03'!colorStrandsWithFewColors"Zuerst die längeren strands färben."	| dict strandsSizes | 	"Längen der strands zählen"	strandsSizes := Array new: numberOfStrands.	strandsSizes atAllPut: 0.	strandsRegistered do: [ :entry |		strandsSizes at: entry put: (strandsSizes at: entry) + 1.		].	dict := Dictionary new.	1 to: strandsSizes size do: [ :si | 		| curStrandSize |		curStrandSize := strandsSizes at: si.		dict at: curStrandSize ifAbsentPut: [ OrderedCollection new ].		(dict at: curStrandSize) add: si. "Alle strandindices der Länge curStrandSize"	].	( dict keys sort: [ :a :b | a >= b ] ) do: [ :key |		"Zuerst die längeren strands"				self colorThisStrandIndices: ( dict at: key )			] ! !!ETileBigRoassal methodsFor: 'building' stamp: 'PeterGraf 1/31/2024 14:10'!buildPolygonsInAllTiles	allTiles do: [ :eTileRoassal | eTileRoassal buildPolygons ]! !!ETileBigRoassal methodsFor: 'building' stamp: 'PeterGraf 2/15/2024 11:37'!colorStrandIndex: aStrandIndex"Einen strand färben. strandCrossings beachten.Beliebig viele Farben."	| ci |		(strandsColorIndices at: aStrandIndex) ifNotNil: [ ^ self ].		"Färbeversuche mit immer mehr Farben"	ci := 0. "Color Index"	[ ci < numberOfStrands ] whileTrue: [		ci := ci + 1.		"strand färben"		self colorStrandIndex: aStrandIndex withColorIndex: ci.		(strandsColorIndices at: aStrandIndex) ifNotNil: [			"strand ist gefärbt"			ci := numberOfStrands + 1 "exit loop" ]]! !!ETileBigRoassal methodsFor: 'building' stamp: 'PeterGraf 2/20/2024 12:20'!colorStrandsWithManyColors"Alle Diamanten mit gleicher Farbe färbenstrands der Länge 4 (squares), 6 (kites) und 8 (freie Bändchen) erst später färben"	| ci | 	"Alle Diamanten mit gleicher Farbe (colorIndex := 1.) färben"	1 to: strandsColorIndices size do: [ :si |		(strandsColorIndices at: si) ifNil: [			(self isDiamondStrandIndex: si) ifTrue: [				self updateColorStrand: si withColorIndex: 1. 				strandsColorIndices at: si put: 1. "aktualisieren" ]]].	"Short strands fiktiv vorfärben"	1 to: strandsColorIndices size do: [ :si |		(strandsColorIndices at: si) ifNil: [			(self isShortStrandIndex: si) ifTrue: [				strandsColorIndices at: si put: 99. ]]].	"So viele Farben wie möglich verwenden."	ci := 0.	[ strandsColorIndices includes: nil ] whileTrue: [ | si |		ci := ci + 1. "nächste Farbe"		si := 0.		[ si < strandsColorIndices size ] whileTrue: [			si := si + 1. "nächster strand"			(strandsColorIndices at: si) ifNil: [				self colorStrandIndex: si withColorIndex: ci.				(strandsColorIndices at: si) ifNotNil: [					"strand wurde gefärbt"					si := strandsColorIndices size. "exit loop" ]]]].	"Short strands neu färben mit wenig Farben"	1 to: strandsColorIndices size do: [ :si |			(strandsColorIndices at: si) = 99 ifTrue: [								strandsColorIndices at: si put: nil.				self colorStrandIndex: si ]].					! !!ETileBigRoassal methodsFor: 'building' stamp: 'PeterGraf 2/15/2024 19:50'!colorStrandIndex: aStrandIndex withColorIndex: aColorIndex"Versuch: Einen strand mit aColorIndex färben. strandCrossings beachten."	(strandsColorIndices at: aStrandIndex) = aColorIndex ifTrue: [ ^ self ].		"colorIndizes der kreuzenden strands entlang des strands prüfen."	(strandCrossingsSet select: [ :e | e first = aStrandIndex ]) 		detect: [ :tu2 | (strandsColorIndices at: tu2 second) = aColorIndex ]		ifNone: [ "strand ist färbbar"  			self updateColorStrand: aStrandIndex withColorIndex: aColorIndex. 			strandsColorIndices at: aStrandIndex put: aColorIndex. "aktualisieren" ]! !!ETileBigRoassal methodsFor: 'building' stamp: 'PeterGraf 2/15/2024 12:09'!buildStrandCrossingsSet"Kreuzungen der Polygone 1, 4 und 5, in allen Tiles.{ 1 . 2 }, strand 1 kreuzt strand 2.strand 1 und strand 2 können also nicht die gleiche Farbe haben.In allen Polygonen sind bereits die strands eingetragen."		strandCrossingsSet := OrderedCollection new.		allTiles do: [ :eTileRoassal |		| s1 s4 s5 |		s1 := (eTileRoassal polygons at: 1) strandIndex.		s4 := (eTileRoassal polygons at: 4) strandIndex.		s5 := (eTileRoassal polygons at: 5) strandIndex.					"symetrische Einträge für Zugriff ohne 'sorted'"		strandCrossingsSet 			add: {s4 . s1}; add: {s1 . s4};			add: {s4 . s5}; add: {s5 . s4}.	].	strandCrossingsSet := strandCrossingsSet asSet! !!ETileBigRoassal methodsFor: 'building' stamp: 'PeterGraf 2/17/2024 13:59'!colorStrandsWithManyColorsBackup"Alle Diamanten mit gleicher Farbe färbenstrands der Länge 4 (squares) und 6 (kites) erst später färben"	| ci | 	"Alle Diamanten mit gleicher Farbe färben"	1 to: strandsColorIndices size do: [ :si |		(strandsColorIndices at: si) ifNil: [			(self isDiamondStrandIndex: si) ifTrue: [				self updateColorStrand: si withColorIndex: 1. 				strandsColorIndices at: si put: 1. "aktualisieren" ]]].	"So viele Farben wie möglich verwenden."	ci := 0.	[ strandsColorIndices includes: nil ] whileTrue: [ | si |		ci := ci + 1. "nächste Farbe"		si := 0.		[ si < strandsColorIndices size ] whileTrue: [			si := si + 1. "nächster strand"			(strandsColorIndices at: si) ifNil: [				self colorStrandIndex: si withColorIndex: ci.				(strandsColorIndices at: si) ifNotNil: [					"strand wurde gefärbt"					si := strandsColorIndices size. "exit loop" ]]]] 						! !!ETileBigRoassal methodsFor: 'building' stamp: 'PeterGraf 2/15/2024 12:09'!setStrandsInPolygons"strands in den Polygonen setzen. numberOfStrandsDas lineDict bereits aufgebaut."	| curStrandIndex |		"strand in allen Polygonen löschen"	allTiles do: [ :eTileRoassal |		eTileRoassal polygons do: [ :polygon | polygon strandIndex: nil ]].	"strand in allen Polygonen setzen"	curStrandIndex := 1.	allTiles do: [ :eTileRoassal |		eTileRoassal polygons do: [ :polygon |			polygon strandIndex ifNil: [  							polygon setStrandRecursively: curStrandIndex.				curStrandIndex := curStrandIndex + 1 ]]].	numberOfStrands := curStrandIndex - 1.! !!ETileBigRoassal methodsFor: 'building' stamp: 'PeterGraf 2/15/2024 11:37'!colorThisStrandIndices: someStrandIndices"Indizes für colorIndexStrandsstrands färben. strandCrossings beachten."	someStrandIndices do: [ :si |		(strandsColorIndices at: si) ifNil: [ self colorStrandIndex: si ]]! !!ETileBigRoassal methodsFor: 'building' stamp: 'PeterGraf 2/15/2024 16:50'!buildAllStrands"nach setStrandsInPolygons"	allStrands := Array new: numberOfStrands.	1 to: allStrands size do: [ :i |		allStrands at: i put: OrderedCollection new.	].		allTiles do: [ :eTile |		eTile polygons do: [ :polygon |			(allStrands at: polygon strandIndex) add: polygon ]].	1 to: allStrands size do: [ :i |		allStrands at: i put: (allStrands at: i) asArray.	].! !!ETileBigRoassal methodsFor: 'file in/out' stamp: 'PeterGraf 2/22/2024 20:22'!fileOutWithExtension: anExtensionString	" 'txt' 'pdf' "	| exText fileRef flexiblePattern tPattern num |	(#( 'txt' 'pdf' ) includes: anExtensionString) ifFalse: [		^ self ].	exText := '.' , anExtensionString.	num := 0.	flexiblePattern := self curFlexiblePattern.	"fileLocator := (FileLocator home / 'eTiles') ensureCreateDirectory."	fileLocator ensureCreateDirectory.	tPattern := flexiblePattern.	[ (fileLocator / (tPattern , exText)) exists ] whileTrue: [		num := num + 1.		tPattern := 			String streamContents: [ :stream | "Umbennennung wie am chromebook"				stream					nextPutAll: flexiblePattern;					space;					nextPut: $(;					nextPutAll: num asString;					nextPut: $) ]].	fileRef := fileLocator / (tPattern , exText).	fileRef writeStreamDo: [ :stream | 		"überschreibt, ohne vorher den alten Inhalt zu löschen"		anExtensionString = 'txt' ifTrue: ["Transcript show: fileRef; cr."			1 to: rows do: [ :i |				1 to: columns do: [ :j |					| eTile |					eTile := allTiles at: i at: j.					1 to: 5 do: [ :k | | polygon |						polygon := eTile polygons at: k.						stream							space;							nextPutAll: (polygon colorIndex ifNil: [ '0' ] ifNotNil: [ polygon colorIndex asString ]) ].					stream cr ] ] ].		anExtensionString = 'pdf' ifTrue: ["Transcript show: fileRef pathString; cr."			canvas zoomToFit.			RSPDFCairoExporter new				fileName: fileRef pathString;				canvas: canvas;				zoomToCurrentCamera;				useDoubleDraw;				export ]. 					] "writeStreamDo:"! !!ETileBigRoassal methodsFor: 'actions' stamp: 'PeterGraf 2/15/2024 11:37'!clearColorsInAllPolygons	1 to: strandsColorIndices size do: [ :i |		self updateColorStrand: i withColorIndex: nil ].		strandsColorIndices := Array new: numberOfStrands.! !!ETileBigRoassal methodsFor: 'actions' stamp: 'PeterGraf 3/10/2024 09:14'!replaceColor"curColorIndexBefore durch curColorIndex ersetzen"	1 to: strandsColorIndices size do: [ :i |		(strandsColorIndices at: i) = curColorIndexBefore ifTrue: [			self colorStrandIndex: i withColorIndex: curColorIndex ]]! !!ETileBigRoassal methodsFor: 'paint' stamp: 'PeterGraf 1/22/2024 00:47'!paintBigFrameOn: aCanvas 	| x y p1 p2 p3 p4|	x := 50 * columns.	y := 50 * rows.		p1 := x negated @ y negated.	p2 := x @ y negated.	p3 := x @ y.	p4 := x negated @ y.		aCanvas add: ( RSPolyline new controlPoints: { p1 . p2 . p3 . p4 . p1 }; color: Color black; capRound ).	! !!ETileBigRoassal methodsFor: 'paint' stamp: 'PeterGraf 2/13/2024 11:57'!paintAllTilesOn: aCanvas 	allTiles do: [ :eTileRoassal | eTileRoassal paintOnCanvas: aCanvas ].! !!ETileBigRoassal methodsFor: 'update' stamp: 'PeterGraf 2/17/2024 15:31'!updateColorStrand: aStrand withColorIndex: aColorIndex"überschreibt""Transcript show: aStrand asString; cr."	allTiles do: [ :eTileRoassal |		eTileRoassal polygons do: [ :polygon |			polygon strandIndex = aStrand ifTrue: [ 				polygon updateRSPolygonColorIndex: aColorIndex.			]	]].! !!ETileBigRoassal methodsFor: 'event handling' stamp: 'PeterGraf 3/6/2024 13:59'!paintColorMenueOnBackup: aCanvas"Im Kreis die aktuelle Farbe"| colorBoxes curColorCircle |colorBoxes := RSGroup new.1 to: colorPalette range size do: [ :i | | rsBox |	rsBox := RSBox new.	rsBox color: (colorPalette range at: i); size: 20.	colorBoxes add: rsBox ].  curColorCircle := RSCircle new	borderColor: Color black; 	color: (colorPalette range at: curColorIndex); 	size: 30.colorBoxes do: [ :cBox |	cBox when: RSMouseLeftClick do: [ :evt |		curColorIndex := colorBoxes indexOf: evt shape.		curColorCircle color: (colorPalette range at: curColorIndex); signalUpdate 	]	].colorBoxes add: curColorCircle. "anhängen, ohne event handler"aCanvas addAll: colorBoxes.RSVerticalLineLayout new verticalGap: 0; on: colorBoxes. colorBoxes do: [ :cBox | cBox setAsFixed ]."colorBoxes translateTopLeftTo: 0@0."! !!ETileBigRoassal methodsFor: 'event handling' stamp: 'PeterGraf 3/9/2024 19:25'!paintColorMenueOn: aCanvas"Im Kreis die aktuelle Farbe"| colorBoxes curColorCircle |curColorCircle := RSCircle new	borderColor: Color black; 	color: (colorPalette range at: curColorIndex); 	size: 30.colorBoxes := RSGroup new.1 to: colorPalette range size do: [ :i | | rsBox |	rsBox := RSBox new.	rsBox color: (colorPalette range at: i); size: 20.	colorBoxes add: rsBox ].  colorBoxes do: [ :cBox |	cBox when: RSMouseLeftClick do: [ :evt |		curColorIndexBefore := curColorIndex.		curColorIndex := colorBoxes indexOf: evt shape.		curColorCircle color: (colorPalette range at: curColorIndex); signalUpdate 	]	].colorBoxes add: curColorCircle. "anhängen, ohne event handler"aCanvas addAll: colorBoxes.RSVerticalLineLayout new verticalGap: 0; on: colorBoxes. colorBoxes do: [ :cBox | cBox setAsFixed ]."colorBoxes translateTopLeftTo: 0@0."! !!ETileBigRoassal methodsFor: 'event handling' stamp: 'PeterGraf 2/29/2024 08:41'!paintMouseClickRightEventsForPolygonsOn: aCanvas"weaving ändern. Event handler für die Polygone eintragen"	allTiles do: [ :eTileRoassal |		#( 1 4 5 ) do: [ :i | | polygon |			polygon := eTileRoassal polygons at: i.			polygon rsPolygon when: RSMouseRightClick do: [ :evt | 				| newWeaving |				polygon polygonIndex = 4 ifTrue: [ newWeaving := $d ] ifFalse: [ 				polygon polygonIndex = 5 ifTrue: [ 					eTileRoassal weaving = $a ifTrue: [ newWeaving := $c ] ifFalse: [  					eTileRoassal weaving = $d ifTrue: [ newWeaving := $b ]					]] ifFalse: [				polygon polygonIndex = 1 ifTrue: [  					eTileRoassal weaving = $b ifTrue: [ newWeaving := $c ] ifFalse: [  					eTileRoassal weaving = $d ifTrue: [ newWeaving := $a ]				 				]]]].				newWeaving ifNotNil: [					| r startRow c startColumn w4 |										eTileRoassal weaving: newWeaving.					polygon rsLinesInner ifNotNil: [ 			.			polygon rsLinesInner do: [ :rsLine |							rsLine pushBack.								rsLine signalUpdate						].											].					polygon rsPolygon pushBack.										polygon rsPolygon signalUpdate.					startRow := (polygon eTile row - 1) % 2 + 1.					startColumn := (polygon eTile column - 1) % 2 + 1.					r := startRow.					[ r <= rows ] whileTrue: [						c := startColumn.						[ c <= columns ]  whileTrue: [							| t p |							t := allTiles at: r at: c.							t weaving: newWeaving.							p := t polygons at: polygon polygonIndex.							p rsLinesInner ifNotNil: [ 					.			p rsLinesInner do: [ :rsLine |									rsLine pushBack.										rsLine signalUpdate								].													].							p rsPolygon pushBack.												p rsPolygon signalUpdate.							c := c + 2.						].						r := r + 2.					]. 					w4 := self weavingAsString.					1 to: 4 do: [ :k |						(fourPattern3 at: k)	 at: 3 put: (w4 at: k)					].													eTileRoassal bigETile updateTitle.									].			] "event handler"]]! !!ETileBigRoassal methodsFor: 'event handling' stamp: 'PeterGraf 3/9/2024 19:27'!paintTextMenueOn: aCanvas| menuLabels |menuLabels := RSGroup new."         1           2           3             4              5              6"	#( 'ExportTxt' 'ExportPdf' 'AutoColor-'  'AutoColor+' 'ClearColors' 'ReplaceColor') do: [ :txt |		menuLabels add: (RSLabel text: txt )		].	(menuLabels at: 1) when: RSMouseLeftClick do: [ :evt |		self fileOutWithExtension: 'txt'.		self canvas morph inform: 'Done'	].		(menuLabels at: 2) when: RSMouseLeftClick do: [ :evt |		self fileOutWithExtension: 'pdf'.		self canvas morph inform: 'Done'.	].		(menuLabels at: 3) when: RSMouseLeftClick do: [ :evt |		self colorStrandsWithFewColors.		canvas signalUpdate			].		(menuLabels at: 4) when: RSMouseLeftClick do: [ :evt |		self colorStrandsWithManyColors.		canvas signalUpdate			].		(menuLabels at: 5) when: RSMouseLeftClick do: [ :evt |		self clearColorsInAllPolygons.		canvas signalUpdate			].		(menuLabels at: 6) when: RSMouseLeftClick do: [ :evt |		self replaceColor.		canvas signalUpdate	].	menuLabels @ ( RSHighlightable new highlightColor: Color black ).aCanvas addAll: menuLabels.RSHorizontalLineLayout new horizontalGap: 10; on:menuLabels. menuLabels translateTopLeftTo: 30@0. menuLabels do: [ :label | label setAsFixed ].! !!ETileBigRoassal methodsFor: 'event handling' stamp: 'PeterGraf 2/29/2024 08:41'!paintMouseClickLeftEventsForPolygonsOnBackup: aCanvas"strands färben. Event handler für die Polygone eintragen"	allTiles do: [ :eTileRoassal |		eTileRoassal polygons do: [ :polygon | 					polygon rsPolygon when: RSMouseLeftClick do: [ :evt | 				(strandsColorIndices at: polygon strandIndex) = curColorIndex ifTrue: [  					"Farbe im strand löschen."					self updateColorStrand: polygon strandIndex withColorIndex: nil . 					strandsColorIndices at: polygon strandIndex put: nil.					"aCanvas signalUpdate."				] ifFalse: [ 					"Geht natürlich nicht immer"					self colorStrandIndex: polygon strandIndex withColorIndex: curColorIndex					"aCanvas signalUpdate."				].							eTileRoassal bigETile updateTitle.				aCanvas signalUpdate.						] "event handler"	] ]! !!ETileBigRoassal methodsFor: 'event handling' stamp: 'PeterGraf 2/29/2024 08:41'!paintMouseClickLeftEventsForPolygonsOn: aCanvas"strand färben. Event handler für jedes Polygone eintragen"	allTiles do: [ :eTileRoassal |		eTileRoassal polygons do: [ :polygon | 					polygon rsPolygon when: RSMouseLeftClick do: [ :evt | 				(strandsColorIndices at: polygon strandIndex) = curColorIndex ifTrue: [  					"Farbe im strand löschen."					self updateColorStrand: polygon strandIndex withColorIndex: nil . 					strandsColorIndices at: polygon strandIndex put: nil.					"aCanvas signalUpdate."				] ifFalse: [ 					"Geht natürlich nicht immer"					self colorStrandIndex: polygon strandIndex withColorIndex: curColorIndex					"aCanvas signalUpdate."				].							eTileRoassal bigETile updateTitle.				aCanvas signalUpdate.						] "event handler"	] ]! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/7/2024 10:48'!withDimension: aBoolean	aBoolean 		ifTrue:  [ self optionSet: 11 ] 		ifFalse: [ self optionReset: 11 ] ! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 1/11/2024 21:42'!canvas	^ canvas! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/22/2024 11:24'!title"^ '012+1a+1a+1a+4a'). z.B."	^  String streamContents: [ :stream |			stream				nextPutAll: (theIndex printStringLength: 3 padded: true );				nextPut: $T;				nextPutAll: ( (fourPattern3 at: 1) copyFrom: 1 to: 2 );				nextPutAll: ( (fourPattern3 at: 2) copyFrom: 1 to: 2 );				nextPutAll: ( (fourPattern3 at: 3) copyFrom: 1 to: 2 );				nextPutAll: ( (fourPattern3 at: 4) copyFrom: 1 to: 2 );				nextPut: $W;				nextPutAll: self weavingAsString;				nextPut: $D;				nextPutAll: (rows printStringLength: 2 padded: true);				nextPutAll: (columns printStringLength: 2 padded: true);"				nextPut: $C;				nextPutAll: ((self class tileColorRanges154 at: theIndex) first printStringLength: 2 padded: true);				nextPutAll: ((self class tileColorRanges154 at: theIndex) second printStringLength: 2 padded: true);"				nextPut: $P;				nextPutAll: self optionsAsString				"; nextPutAll: self curFlexiblePattern" "Test"			]! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/23/2024 09:35'!withAutoColoringFew: aBoolean	aBoolean 		ifTrue:  [ self optionSet: 4 ] 		ifFalse: [ self optionReset: 4 ] ! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 1/30/2024 19:06'!theIndex	^ theIndex! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/22/2024 19:28'!tileColorIndices2D: anObject	tileColorIndices2D := anObject! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/7/2024 10:47'!withDimension	^	self optionIsSet: 11! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/12/2024 18:31'!colorForColorIndexBackup: colorIndex"Siehe colorbrewer2.orgRSQualitativeColorPaletteAnzahl der Farben            3,4   5    6,7    8     9   10,11,12  gutaccent      p    n     n     n                   xdark2       p    p     p     p                   xxpaired      p    p     p     n     n     n       xxxxset1        p    p     p     p     p             xxxset2        p    p     p     pset3        p    p     p     p     n     np: print friendlyn: normalRSSequentialColorPalette, print friendly bis 5 YlGnBugreys    für 3 bis 9 FarbenRdGy     für 4, 5 FarbenSpectral für 3 bis 12 Farben"	colorIndex ifNil: [ 		self withLines ifTrue: [ ^ self backgroundColor ].		"^ colorPalette range at: 14 " "schwaches grau"		"^ Color veryVeryLightGray"		^	Color lightCyan	].	^ colorPalette range at: (colorIndex min: colorPalette range size ) ! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/23/2024 09:36'!withAutoColoringMany: aBoolean	aBoolean 		ifTrue:  [ self optionSet: 5 ] 		ifFalse: [ self optionReset: 5 ] ! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/12/2024 18:33'!colorForColorIndex: colorIndex"Siehe colorbrewer2.orgRSQualitativeColorPaletteAnzahl der Farben            3,4   5    6,7    8     9   10,11,12  gutaccent      p    n     n     n                   xdark2       p    p     p     p                   xxpaired      p    p     p     n     n     n       xxxxset1        p    p     p     p     p             xxxset2        p    p     p     pset3        p    p     p     p     n     np: print friendlyn: normalRSSequentialColorPalette, print friendly bis 5 YlGnBugreys    für 3 bis 9 FarbenRdGy     für 4, 5 FarbenSpectral für 3 bis 12 Farben"	(colorIndex isNil or: [ colorIndex isZero ]) ifTrue: [ 		self withLines ifTrue: [ ^ self backgroundColor ].		"^ colorPalette range at: 14 " "schwaches grau"		"^ Color veryVeryLightGray"		^	Color lightCyan	].	^ colorPalette range at: (colorIndex min: colorPalette range size ) ! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/1/2024 11:35'!withLines	^	self optionIsSet: 1! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/7/2024 12:51'!withTilePatterns	^	self optionIsSet: 13! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/15/2024 11:40'!strandsRegistered	^ strandsRegistered! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/23/2024 09:35'!withAutoColoringFew	^	self optionIsSet: 4! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 1/6/2024 11:18'!rows	^ rows! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/20/2024 12:54'!fourPattern3: anObject"#( '+1a' '+1a' '+1a' '+1a' ) z.B.""	fourPatterns copy do: [ :pattern |		(			( '+-'   includes: (pattern at: 1) ) and: [ 			( '1234' includes: (pattern at: 2) ) and: [ 			( 'abcd' includes: (pattern at: 3) ) ]]		)		ifFalse: [ fourPatterns := #( '+1a' '+1a' '+1a' '+1a' ) ]	]."	fourPattern3 := anObject! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/5/2024 15:42'!theIndex: anIndex "1..154"	theIndex := anIndex.		minRows := (self class tileSizes154 at: theIndex ) first.	minColumns := (self class tileSizes154 at: theIndex ) second.! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/1/2024 11:36'!withBigFrame	^ self optionIsSet: 3! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/2/2024 12:07'!weavingAsString	^  String streamContents: [ :stream |				stream			nextPut: ( (allTiles at: 1 at: 1) weaving );			nextPut: ( (allTiles at: 1 at: 2) weaving );			nextPut: ( (allTiles at: 2 at: 1) weaving );			nextPut: ( (allTiles at: 2 at: 2) weaving ).	]! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 3/6/2024 15:00'!backgroundColor	^ Color white! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 3/5/2024 19:20'!optionsAsString	^ String streamContents: [ :stream |			self withTilePatterns  	ifTrue: [ stream nextPut: $t ].			self withWeaving      	ifTrue: [ stream nextPut: $w ].			self withDimension    	ifTrue: [ stream nextPut: $d ].			self withBigFrame      	ifTrue: [ stream nextPut: $b ].			self withTileFrame     	ifTrue: [ stream nextPut: $i ].			self withLines       		ifTrue: [ stream nextPut: $l ].			"self withColorRange  	ifTrue: [ stream nextPut: $c ]."			"self withAutoColoringFew 	ifTrue: [ stream nextPut: $f ]."			"self withPdf       		ifTrue: [ stream nextPut: $p ]."			"self withError       	ifTrue: [ stream nextPutAll: 'ERROR' ]."		]! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 1/6/2024 11:18'!columns	^ columns! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 1/8/2024 14:05'!allTiles	^ allTiles! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/15/2024 11:43'!strandCrossingsSet	^ strandCrossingsSet! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/1/2024 11:36'!withTileFrame	^ self optionIsSet: 2 ! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/23/2024 09:35'!withAutoColoringMany	^	self optionIsSet: 5! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/3/2024 22:54'!withError	^	self optionIsSet: 9! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/23/2024 14:40'!curFlexiblePattern"curFlexiblePattern 23.02.2024         1         2         3         4  1234567890123456789012345678901234567890nnnFilename = 'nnn'['Ttttt']['Wwwww']['Drrcc']['Frfcf']['P...']'.txt'nnn				'001'..'154' Index, mandatoryTtttt			t = '+1'|'+2'|'+3'|'+4'|'-1'|'-2'|'-3'|'-4'					optional, is info only, default: from tableWwwww 			w = 'a'|'b'|'c'|'d'					weavings for t11 t12 t21 t22					optional, default: from tableDrrcc		 	rr = '02'..'99', cc = '02'..'99'					rr = number of rows					cc = number of columns					optional, default: rr, cc from tableFrfcf		 	rf = '01'..'99', cf = '01'..'99'					rf = rows factor					cf = columns factor					optional, default: '01', '01'P...				options, up to ' ' or '.',					default: false											bitIndex					't'	withTilePatterns									13			info					'w'	withWeaving 										10					'd'	withDimension 										11					'b'	withBigFrame 										3					'i'	withTileFrame										2					'l'	withLines 											1					'f'	color with few colors							4					'm'	color with many colors						5					'p'  export PDF, close window					6   							withError (internal)							9   ""Cmima		 	mi = minimale Anzahl Farben					ma = maximale Anzahl Farben					optional, is info only, default: aus Tabelle""							withFactor  										14""					'c'	withColorRange 									12			info""^ '111WabcdD04040101C0099Pwdcbl'). z.B."	^	String streamContents: [ :stream |			stream nextPutAll: (theIndex printStringLength: 3 padded: true ).			self withTilePatterns ifTrue: [				stream 					nextPut: $T;					nextPutAll: ( (fourPattern3 at: 1) copyFrom: 1 to: 2 );					nextPutAll: ( (fourPattern3 at: 2) copyFrom: 1 to: 2 );					nextPutAll: ( (fourPattern3 at: 3) copyFrom: 1 to: 2 );					nextPutAll: ( (fourPattern3 at: 4) copyFrom: 1 to: 2 ) ].			self withWeaving ifTrue: [				stream nextPut: $W; nextPutAll: self weavingAsString ].			self withDimension ifTrue: [				stream 					nextPut: $D; 					nextPutAll: (rows printStringLength: 2 padded: true);					nextPutAll: (columns printStringLength: 2 padded: true) ]."			self withColorRange ifTrue: [				stream   					nextPut: $C;					nextPutAll: ((self class tileColorRanges154 at: theIndex) first printStringLength: 2 padded: true);					nextPutAll: ((self class tileColorRanges154 at: theIndex) second printStringLength: 2 padded: true) ]."			stream 				nextPut: $P; 				nextPutAll: self optionsAsString		]! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/7/2024 12:51'!withTilePatterns: aBoolean	aBoolean 		ifTrue:  [ self optionSet: 13 ] 		ifFalse: [ self optionReset: 13 ] ! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 1/21/2024 18:35'!canvas: aRSCanvas	canvas := aRSCanvas! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/1/2024 11:37'!withBigFrame: aBoolean	aBoolean 		ifTrue:  [ self optionSet: 3 ] 		ifFalse: [ self optionReset: 3 ] ! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/7/2024 10:48'!withWeaving: aBoolean	aBoolean 		ifTrue:  [ self optionSet: 10 ] 		ifFalse: [ self optionReset: 10 ] ! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/4/2024 11:12'!updateTitle	self canvas morph owner setLabel: self title.	self withError: false  "Nur einmal ausgeben"! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/5/2024 15:43'!minRows	^ minRows! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 1/30/2024 12:53'!lineDict	^ lineDict! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 3/2/2024 12:44'!start"Für den Export als PDF über options:- kein	self paintMouseClickLeftEventsForPolygonsOn: self canvas.- kein	self paintMouseClickRightEventsForPolygonsOn: self canvas.- kein canvad @ RSCanvasController- canvas schliessen"	| win |	" ... build lineDict "	self buildPolygonsInAllTiles.	"find strands"	self setStrandsInPolygons.	self buildAllStrands.	self isSelfCrossingStrandIndex: 1.		"build strandCrossings"	self buildStrandCrossingsSet.	strandsColorIndices := Array new: numberOfStrands.	self withError ifTrue: [		tileColorIndices2D := nil.		self withPdf: false ].	self canvas: RSCanvas new.	canvas color: self backgroundColor.	self withPdf ifFalse: [		self paintColorMenueOn: canvas.		self paintTextMenueOn: canvas ].	self paintAllTilesOn: self canvas.	tileColorIndices2D ifNotNil: [ 		"Set colorindices in all polygons"		1 to: rows do: [ :i |			1 to: columns do: [ :j |				| eTile |				eTile := allTiles at: i at: j.				1 to: 5 do: [ :k | | polygon color5Indices |					polygon := eTile polygons at: k.					color5Indices := 						tileColorIndices2D							at: eTile row							at: eTile column.					polygon updateRSPolygonColorIndex: (color5Indices at: k). "nil or anInt >= 1"					"update colorindex"					strandsColorIndices at: polygon strandIndex put: (color5Indices at: k) ]]]].	self withAutoColoringFew ifTrue: [ self colorStrandsWithFewColors ].	self withAutoColoringMany ifTrue: [ self colorStrandsWithManyColors ].	self withPdf ifFalse: [		self paintMouseClickLeftEventsForPolygonsOn: self canvas.		self paintMouseClickRightEventsForPolygonsOn: self canvas ].	self withBigFrame ifTrue: [ self paintBigFrameOn: self canvas ].	self withPdf ifFalse: [		canvas @ RSCanvasController "This makes the helpmenue in rscanvas" ].	canvas zoomToFit.	win := canvas open.	win position: 0 @ 0. "top left"	win extent:		(800 min: (600 max: 100 * columns))		@ (800 min: (780 max: 100 * rows)).	canvas zoomToFit.	self updateTitle.	"canvas signalUpdate."	canvas camera translateTo: 0 @ 0.	self withPdf ifTrue: [		"self withPdf: false."		self fileOutWithExtension: 'pdf'.		win close ]! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/1/2024 11:38'!withLines: aBoolean	aBoolean 		ifTrue:  [ self optionSet: 1 ] 		ifFalse: [ self optionReset: 1 ] ! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 1/13/2024 18:04'!lineColor	^ Color black! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/3/2024 18:07'!withPdf	^	self optionIsSet: 6! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 1/24/2024 14:26'!curColorIndex	^ curColorIndex! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/15/2024 11:44'!strandCrossingsSet: anObject	strandCrossingsSet := anObject! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/6/2024 13:09'!fileLocator: anObject	fileLocator := anObject! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/6/2024 13:09'!fileLocator	^ fileLocator! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/22/2024 19:27'!tileColorIndices2D	^ tileColorIndices2D! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/3/2024 22:54'!withError: aBoolean	aBoolean 		ifTrue:  [ self optionSet: 9 ] 		ifFalse: [ self optionReset: 9 ] ! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/15/2024 12:33'!allStrands	^ allStrands! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/7/2024 10:46'!withWeaving	^	self optionIsSet: 10! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/5/2024 15:43'!minColumns	^ minColumns! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/20/2024 12:53'!fourPattern3"#( '+1a' '+1a' '+1a' '+1a' ) z.B."	^ fourPattern3! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/1/2024 11:38'!withTileFrame: aBoolean	aBoolean 		ifTrue:  [ self optionSet: 2 ] 		ifFalse: [ self optionReset: 2 ] ! !!ETileBigRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/3/2024 18:07'!withPdf: aBoolean	aBoolean 		ifTrue:  [ self optionSet: 6 ] 		ifFalse: [ self optionReset: 6 ] ! !!ETileBigRoassal methodsFor: 'comment' stamp: 'PeterGraf 2/9/2024 11:30'!readMe"Wegen 'matrix' not understood.RSAbstractCamSetter>>#set: := set: aBlock	| camera |	self setCanvasCamera.	camera := canvas camera copy.	""camera matrix: canvas camera matrix copy.""	self shouldUseDoubleDraw 		ifTrue: [ canvas morph drawOnMockCanvas ].	self setCamera.	aBlock value.	canvas camera: camera."! !!ETileBigRoassal methodsFor: 'setter' stamp: 'PeterGraf 1/21/2024 18:17'!allTiles: anArray2D	allTiles := anArray2D! !!ETileBigRoassal methodsFor: 'setter' stamp: 'PeterGraf 1/6/2024 11:18'!rows: anInteger	rows := anInteger! !!ETileBigRoassal methodsFor: 'setter' stamp: 'PeterGraf 1/6/2024 11:18'!columns: anInteger	columns := anInteger! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ETileBigRoassal class	instanceVariableNames: ''!!ETileBigRoassal class methodsFor: 'accessing' stamp: 'PeterGraf 2/20/2024 14:12'!fourPattern3StringAt: index	| fourPattern2 weaving arr |		fourPattern2 := self fourPattern2StringsAt: index. " #('+1' '+2' '+3' '+4') "	weaving := (self defaultWeavingStringsAt: index) at: 1. " #( 'abcd' 'baba' 'cdcd' ) at: 1 "		arr := Array new: 4.		1 to: 4 do: [ :i |		arr at: i put: (fourPattern2 at: i) , ( weaving copyFrom: i to: i )	].	^	arr		! !!ETileBigRoassal class methodsFor: 'constants' stamp: 'PeterGraf 2/20/2024 19:25'!tile6x6Sizes154"154 Zeilen und Spalten, damit BigTileRoassal eine Fliese ist."" minRow minColumn"^ #(#(6 6)     "1"#(6 6)     "2" "4 4"#(6 6)   "3"#(6 6)    "4"#(6 6)     "5"  "8 8" "8 colors needed 2"#(6 6)     "6" "8 4"#(6 6)    "7" "12 4"#(6 6)     "8"#(6 6)    "9"#(6 6)   "10"#(6 6)   "11"#(6 6)    "12"#(6 6)  "13"#(6 6)   "14"#(6 6)    "15"#(6 6)  "16"#(6 6)    "17"  "1 color?"#(6 6)    "18"#(6 6)   "19"#(6 6)    "20"#(6 6)    "21"#(6 6)    "22"#(6 6)    "23"#(6 6)    "24"#(6 6)    "25"#(6 6)    "26"#(6 6)    "27"#(6 6)    "28"#(6 6)    "29"#(6 6)    "30"#(6 6)    "31"#(6 6)    "32" "+"#(6 6)    "33"#(6 6)    "34"#(6 6)    "35"#(6 6)    "36"#(6 6)  "37"   "longest"#(6 6)   "38"#(6 6)    "39"#(6 6)    "40"#(6 6)    "41"#(6 6)   "42"#(6 6)  "43"#(6 6)    "44"#(6 6)  "45"   "interesting"#(6 6)    "46"#(6 6)    "47"#(6 6)    "48"#(6 6)    "49"#(6 6)   "50"#(6 6)   "51"#(6 6)   "52"#(6 6)    "53"#(6 6)    "54"#(6 6)    "55"#(6 6)  "56"    "55 colors?"#(6 6)    "57"#(6 6)    "58"#(6 6)    "59"#(6 6)    "60"  "++ 1 very interesting connectivity"#(6 6)  "61"#(6 6)   "62"#(6 6)  "63"#(6 6)    "64"#(6 6)    "65"#(6 6)    "66"#(6 6)    "67"#(6 6)  "68"#(6 6)    "69"#(6 6)    "70"#(6 6)    "71"#(6 6)    "72"#(6 6)    "73"#(6 6)   "74"#(6 6)    "75"#(6 6)    "76"#(6 6)    "77"#(6 6)  "78"#(6 6)    "79"#(6 6)    "80"#(6 6)    "81"#(6 6)    "82" "8 4"#(6 6)    "83"#(6 6)  "84"  "8 colors needed; a beauty"#(6 6)   "85"#(6 6)    "86"#(6 6)  "87"#(6 6)   "88"#(6 6)  "89"#(6 6)    "90"#(6 6)    "91"#(6 6)   "92"#(6 6)   "93"#(6 6)    "94"#(6 6)    "95"#(6 6)   "96"#(6 6)    "97"#(6 6)    "98"#(6 6)    "99"#(6 6)   "100"#(6 6)   "101"#(6 6)   "102"#(6 6)   "103"#(6 6)   "104"#(6 6)   "105"#(6 6)   "106"#(6 6)  "107"#(6 6)   "108"#(6 6)   "109"#(6 6) "110"#(6 6)   "111"#(6 6)  "112"#(6 6)   "113"#(6 6)   "114"#(6 6)   "115"#(6 6) "116"#(6 6) "117"#(6 6)   "118"#(6 6)   "119"#(6 6) "120"#(6 6)   "121"#(6 6)   "122"#(6 6)   "123"#(6 6)   "124"#(6 6)   "125"#(6 6)   "126"#(6 6)   "127"#(6 6)   "128"#(6 6)   "129"#(6 6)   "130"#(6 6)   "131"#(6 6)  "132"#(6 6)   "133"#(6 6)  "134"#(6 6)   "135"#(6 6)   "136"#(6 6)   "137"#(6 6)   "138"#(6 6)   "139"#(6 6)   "140"#(6 6)   "141"#(6 6)   "142"#(6 6)   "143"#(6 6)   "144"#(6 6)   "145"#(6 6)   "146"#(6 6)   "147"#(6 6)  "148"#(6 6)   "149"#(6 6)   "150"#(6 6)   "151"#(6 6)   "152"#(6 6)   "153"#(6 6)   "154").! !!ETileBigRoassal class methodsFor: 'constants' stamp: 'PeterGraf 1/13/2024 17:21'!frameColor 	^ Color black ! !!ETileBigRoassal class methodsFor: 'constants' stamp: 'PeterGraf 2/21/2024 23:24'!tileSizes154"154 Zeilen und Spalten, damit BigTileRoassal eine Fliese ist."" minRow minColumn"^ #(#(4 4)     "1 #(4 4)"#(4 4)     "2" "4 4"#(16 16)   "3"#(16 8)    "4"#(4 4)     "5"  "8 8" "8 colors needed 2"#(4 4)     "6" "8 4"#(12 4)    "7" "12 4"#(4 4)     "8"#(8 16)    "9"#(16 8)   "10"#(8 16)   "11"#(4 8)    "12"#(12 12)  "13"#(12 4)   "14"#(4 4)    "15"#(12 12)  "16"#(4 4)    "17"  "1 color?"#(4 8)    "18"#(16 8)   "19"#(4 4)    "20"#(4 4)    "21"#(4 8)    "22"#(4 8)    "23"#(4 8)    "24"#(8 4)    "25"#(8 4)    "26"#(8 4)    "27"#(8 4)    "28"#(4 4)    "29"#(4 4)    "30"#(4 4)    "31"#(8 4)    "32" "+"#(8 4)    "33"#(8 4)    "34"#(8 4)    "35"#(4 4)    "36"#(24 12)  "37"   "longest"#(16 4)   "38"#(8 4)    "39"#(4 4)    "40"#(4 4)    "41"#(12 4)   "42"#(16 16)  "43"#(8 8)    "44"#(20 20)  "45"   "interesting"#(4 4)    "46"#(8 4)    "47"#(8 4)    "48"#(8 8)    "49"#(8 16)   "50"#(8 16)   "51"#(4 12)   "52"#(8 8)    "53"#(8 4)    "54"#(4 4)    "55"#(20 20)  "56"    "55 colors?"#(8 8)    "57"#(4 8)    "58"#(4 4)    "59"#(4 4)    "60"  "++ 1 very interesting connectivity"#(16 16)  "61"#(12 4)   "62"#(16 16)  "63"#(8 4)    "64"#(8 4)    "65"#(8 4)    "66"#(8 4)    "67"#(12 12)  "68"#(8 4)    "69"#(8 4)    "70"#(8 4)    "71"#(8 4)    "72"#(8 4)    "73"#(16 4)   "74"#(4 8)    "75"#(8 4)    "76"#(8 4)    "77"#(16 16)  "78"#(8 4)    "79"#(8 8)    "80"#(8 4)    "81"#(4 8)    "82" "8 4"#(4 4)    "83"#(16 16)  "84"  "8 colors needed; a beauty"#(12 4)   "85"#(4 4)    "86"#(16 16)  "87"#(4 12)   "88"#(20 20)  "89"#(4 4)    "90"#(8 4)    "91"#(8 16)   "92"#(4 16)   "93"#(8 8)    "94"#(4 8)    "95"#(4 12)   "96"#(4 8)    "97"#(4 8)    "98"#(4 8)    "99"#(4 4)   "100"#(8 4)   "101"#(4 8)   "102"#(8 4)   "103"#(8 4)   "104"#(4 4)   "105"#(4 4)   "106"#(12 4)  "107"#(8 4)   "108"#(8 8)   "109"#(20 20) "110"#(4 4)   "111"#(12 4)  "112"#(8 4)   "113"#(4 8)   "114"#(4 8)   "115"#(20 20) "116"#(16 16) "117"#(4 4)   "118"#(4 4)   "119"#(16 16) "120"#(4 4)   "121"#(4 4)   "122"#(8 4)   "123"#(8 4)   "124"#(8 4)   "125"#(4 4)   "126"#(8 8)   "127"#(4 4)   "128"#(4 4)   "129"#(8 4)   "130"#(8 4)   "131"#(12 4)  "132"#(4 8)   "133"#(16 4)  "134"#(8 8)   "135"#(4 4)   "136"#(4 4)   "137"#(4 4)   "138"#(4 4)   "139"#(4 4)   "140"#(8 4)   "141"#(4 8)   "142"#(4 4)   "143"#(4 4)   "144"#(4 4)   "145"#(4 4)   "146"#(4 4)   "147"#(4 12)  "148"#(4 4)   "149"#(8 4)   "150"#(4 4)   "151"#(4 8)   "152"#(4 8)   "153"#(4 4)   "154").! !!ETileBigRoassal class methodsFor: 'constants' stamp: 'PeterGraf 2/20/2024 14:52'!tile4x4Sizes154"154 Zeilen und Spalten, damit BigTileRoassal eine Fliese ist."" minRow minColumn"^ #(#(4 4)     "1"#(4 4)     "2" "4 4"#(4 4)   "3"#(4 4)    "4"#(4 4)     "5"  "8 8" "8 colors needed 2"#(4 4)     "6" "8 4"#(4 4)    "7" "12 4"#(4 4)     "8"#(4 4)    "9"#(4 4)   "10"#(4 4)   "11"#(4 4)    "12"#(4 4)  "13"#(4 4)   "14"#(4 4)    "15"#(4 4)  "16"#(4 4)    "17"  "1 color?"#(4 4)    "18"#(4 4)   "19"#(4 4)    "20"#(4 4)    "21"#(4 4)    "22"#(4 4)    "23"#(4 4)    "24"#(4 4)    "25"#(4 4)    "26"#(4 4)    "27"#(4 4)    "28"#(4 4)    "29"#(4 4)    "30"#(4 4)    "31"#(4 4)    "32" "+"#(4 4)    "33"#(4 4)    "34"#(4 4)    "35"#(4 4)    "36"#(4 4)  "37"   "longest"#(4 4)   "38"#(4 4)    "39"#(4 4)    "40"#(4 4)    "41"#(4 4)   "42"#(4 4)  "43"#(4 4)    "44"#(4 4)  "45"   "interesting"#(4 4)    "46"#(4 4)    "47"#(4 4)    "48"#(4 4)    "49"#(4 4)   "50"#(4 4)   "51"#(4 4)   "52"#(4 4)    "53"#(4 4)    "54"#(4 4)    "55"#(4 4)  "56"    "55 colors?"#(4 4)    "57"#(4 4)    "58"#(4 4)    "59"#(4 4)    "60"  "++ 1 very interesting connectivity"#(4 4)  "61"#(4 4)   "62"#(4 4)  "63"#(4 4)    "64"#(4 4)    "65"#(4 4)    "66"#(4 4)    "67"#(4 4)  "68"#(4 4)    "69"#(4 4)    "70"#(4 4)    "71"#(4 4)    "72"#(4 4)    "73"#(4 4)   "74"#(4 4)    "75"#(4 4)    "76"#(4 4)    "77"#(4 4)  "78"#(4 4)    "79"#(4 4)    "80"#(4 4)    "81"#(4 4)    "82" "8 4"#(4 4)    "83"#(4 4)  "84"  "8 colors needed; a beauty"#(4 4)   "85"#(4 4)    "86"#(4 4)  "87"#(4 4)   "88"#(4 4)  "89"#(4 4)    "90"#(4 4)    "91"#(4 4)   "92"#(4 4)   "93"#(4 4)    "94"#(4 4)    "95"#(4 4)   "96"#(4 4)    "97"#(4 4)    "98"#(4 4)    "99"#(4 4)   "100"#(4 4)   "101"#(4 4)   "102"#(4 4)   "103"#(4 4)   "104"#(4 4)   "105"#(4 4)   "106"#(4 4)  "107"#(4 4)   "108"#(4 4)   "109"#(4 4) "110"#(4 4)   "111"#(4 4)  "112"#(4 4)   "113"#(4 4)   "114"#(4 4)   "115"#(4 4) "116"#(4 4) "117"#(4 4)   "118"#(4 4)   "119"#(4 4) "120"#(4 4)   "121"#(4 4)   "122"#(4 4)   "123"#(4 4)   "124"#(4 4)   "125"#(4 4)   "126"#(4 4)   "127"#(4 4)   "128"#(4 4)   "129"#(4 4)   "130"#(4 4)   "131"#(4 4)  "132"#(4 4)   "133"#(4 4)  "134"#(4 4)   "135"#(4 4)   "136"#(4 4)   "137"#(4 4)   "138"#(4 4)   "139"#(4 4)   "140"#(4 4)   "141"#(4 4)   "142"#(4 4)   "143"#(4 4)   "144"#(4 4)   "145"#(4 4)   "146"#(4 4)   "147"#(4 4)  "148"#(4 4)   "149"#(4 4)   "150"#(4 4)   "151"#(4 4)   "152"#(4 4)   "153"#(4 4)   "154").! !!ETileBigRoassal class methodsFor: 'constants' stamp: 'PeterGraf 1/13/2024 16:25'!lineColor 	^ Color black ! !!ETileBigRoassal class methodsFor: 'constants' stamp: 'PeterGraf 2/12/2024 00:39'!tileColorRanges154" minimale Anzahl der Farben, maximale Anzahl der Farbenohne Diamanten00 99 für unbekannt"^ #(#(2 6)     "1"#(2 3)     "2"#(9 99)   "3"#(4 4)    "4"#(2 4)     "5"  "8 colors needed 2"#(2 5)     "6"#(3 8)    "7"#(2 4)     "8"#(4 4)    "9"#(4 4)   "10"#(4 4)   "11"#(2 2)    "12"#(4 6)  "13"#(2 2)   "14"#(1 1)    "15"#(3 3)  "16"#(1 1)    "17"#(2 2)    "18"#(4 8)   "19"#(1 1)    "20"#(1 1)    "21"#(2 2)    "22"#(2 8)    "23" "+"#(3 4)    "24"#(4 7)    "25"#(2 2)    "26"#(2 2)    "27"#(2 8)    "28"#(1 1)    "29"#(2 4)    "30"#(2 4)    "31"#(3 4)    "32" "+"#(2 2)    "33"#(4 4)    "34"#(2 2)    "35"#(2 4)    "36"#(6 6)  "37"   "longest"#(2 2)   "38"#(4 14)    "39"#(2 4)    "40"#(2 4)    "41"#(3 4)   "42"#(5 7)  "43"#(4 6)    "44"#(6 10)  "45"   "interesting"#(2 4)    "46"#(3 6)    "47"#(2 2)    "48"#(4 8)    "49"#(8 8)   "50"#(5 8)   "51"#(2 2)   "52"#(2 9)    "53"#(2 2)    "54"#(2 3)    "55"#(5 5)  "56"    "55 colors?"#(4 8)    "57"#(2 2)    "58"#(2 5)    "59"#(1 1)    "60"  "++ 1 very interesting connectivity"#(5 72)  "61"#(2 2)   "62"#(5 16)  "63"#(2 2)    "64"#(2 2)    "65"#(3 4)    "66"#(4 10)    "67"#(4 9)  "68"#(2 2)    "69"#(2 2)    "70"#(2 2)    "71"#(4 14)    "72"#(3 12)    "73"#(2 2)   "74"#(3 6)    "75"#(2 4)    "76"#(5 8)    "77"#(6 13)  "78"#(2 2)    "79"#(3 10)    "80"#(3 5)    "81"#(2 99)    "82"#(2 4)    "83"#(8 16)  "84"  "8 colors needed; a beauty"#(3 4)   "85"#(2 4)    "86"#(4 8)  "87"#(3 4)   "88"#(5 5)  "89"#(2 5)    "90"#(2 2)    "91"#(4 4)   "92"#(2 2)   "93"#(3 8)    "94"#(4 7)    "95"#(2 12)   "96"#(2 8)    "97"#(2 2)    "98"#(4 14)    "99"#(2 5)   "100"#(3 6)   "101"#(4 4)   "102"#(4 6)   "103"#(2 4)   "104"#(2 9)   "105"#(2 5)   "106"#(3 8)  "107"#(4 10)   "108"#(3 9)   "109" "+"#(5 5) "110"#(1 1)   "111"#(2 2)  "112"#(3 4)   "113" "+"#(3 4)   "114"#(3 6)   "115"#(6 20) "116"#(4 9) "117"#(1 5)   "118"#(3 6)   "119"#(5 10) "120" "+"#(2 4)   "121"#(3 6)   "122"#(2 4)   "123"#(4 4)   "124"#(4 6)   "125"#(3 4)   "126"#(2 4)   "127"#(2 4)   "128"#(2 7)   "129" "+"#(2 10)   "130"#(2 2)   "131"#(2 2)  "132"#(3 6)   "133"#(2 2)  "134"#(3 8)   "135"#(2 4)   "136"#(2 4)   "137"#(2 4)   "138"#(3 8)   "139"#(2 8)   "140"#(3 7)   "141"#(3 4)   "142" "++"#(3 12)   "143"#(2 5)   "144" "+ Schleifchen"#(2 4)   "145"#(3 6)   "146"#(2 10)   "147"#(2 10)  "148"#(3 10)   "149"#(3 10)   "150"#(2 8)   "151"#(4 4)   "152"#(4 4)   "153"#(2 8)   "154").! !!ETileBigRoassal class methodsFor: 'constants' stamp: 'PeterGraf 2/20/2024 14:40'!tile1x1Sizes154ZuKLein"154 Zeilen und Spalten, damit BigTileRoassal eine Fliese ist."" minRow minColumn"^ #(#(1 1)     "1 #(1 1)"#(1 1)     "2" "4 4"#(1 1)   "3"#(1 1)    "4"#(1 1)     "5"  "8 8" "8 colors needed 2"#(1 1)     "6" "8 4"#(1 1)    "7" "12 4"#(1 1)     "8"#(1 1)    "9"#(1 1)   "10"#(1 1)   "11"#(1 1)    "12"#(1 1)  "13"#(1 1)   "14"#(1 1)    "15"#(1 1)  "16"#(1 1)    "17"  "1 color?"#(1 1)    "18"#(1 1)   "19"#(1 1)    "20"#(1 1)    "21"#(1 1)    "22"#(1 1)    "23"#(1 1)    "24"#(1 1)    "25"#(1 1)    "26"#(1 1)    "27"#(1 1)    "28"#(1 1)    "29"#(1 1)    "30"#(1 1)    "31"#(1 1)    "32" "+"#(1 1)    "33"#(1 1)    "34"#(1 1)    "35"#(1 1)    "36"#(1 1)  "37"   "longest"#(1 1)   "38"#(1 1)    "39"#(1 1)    "40"#(1 1)    "41"#(1 1)   "42"#(1 1)  "43"#(1 1)    "44"#(1 1)  "45"   "interesting"#(1 1)    "46"#(1 1)    "47"#(1 1)    "48"#(1 1)    "49"#(1 1)   "50"#(1 1)   "51"#(1 1)   "52"#(1 1)    "53"#(1 1)    "54"#(1 1)    "55"#(1 1)  "56"    "55 colors?"#(1 1)    "57"#(1 1)    "58"#(1 1)    "59"#(1 1)    "60"  "++ 1 very interesting connectivity"#(1 1)  "61"#(1 1)   "62"#(1 1)  "63"#(1 1)    "64"#(1 1)    "65"#(1 1)    "66"#(1 1)    "67"#(1 1)  "68"#(1 1)    "69"#(1 1)    "70"#(1 1)    "71"#(1 1)    "72"#(1 1)    "73"#(1 1)   "74"#(1 1)    "75"#(1 1)    "76"#(1 1)    "77"#(1 1)  "78"#(1 1)    "79"#(1 1)    "80"#(1 1)    "81"#(1 1)    "82" "8 4"#(1 1)    "83"#(1 1)  "84"  "8 colors needed; a beauty"#(1 1)   "85"#(1 1)    "86"#(1 1)  "87"#(1 1)   "88"#(1 1)  "89"#(1 1)    "90"#(1 1)    "91"#(1 1)   "92"#(1 1)   "93"#(1 1)    "94"#(1 1)    "95"#(1 1)   "96"#(1 1)    "97"#(1 1)    "98"#(1 1)    "99"#(1 1)   "100"#(1 1)   "101"#(1 1)   "102"#(1 1)   "103"#(1 1)   "104"#(1 1)   "105"#(1 1)   "106"#(1 1)  "107"#(1 1)   "108"#(1 1)   "109"#(1 1) "110"#(1 1)   "111"#(1 1)  "112"#(1 1)   "113"#(1 1)   "114"#(1 1)   "115"#(1 1) "116"#(1 1) "117"#(1 1)   "118"#(1 1)   "119"#(1 1) "120"#(1 1)   "121"#(1 1)   "122"#(1 1)   "123"#(1 1)   "124"#(1 1)   "125"#(1 1)   "126"#(1 1)   "127"#(1 1)   "128"#(1 1)   "129"#(1 1)   "130"#(1 1)   "131"#(1 1)  "132"#(1 1)   "133"#(1 1)  "134"#(1 1)   "135"#(1 1)   "136"#(1 1)   "137"#(1 1)   "138"#(1 1)   "139"#(1 1)   "140"#(1 1)   "141"#(1 1)   "142"#(1 1)   "143"#(1 1)   "144"#(1 1)   "145"#(1 1)   "146"#(1 1)   "147"#(1 1)  "148"#(1 1)   "149"#(1 1)   "150"#(1 1)   "151"#(1 1)   "152"#(1 1)   "153"#(1 1)   "154").! !!ETileBigRoassal class methodsFor: 'constants' stamp: 'PeterGraf 3/10/2024 14:41'!fourPattern3Names154Save"use deepCopy""154 verschiedene fourPatternNames mit default weaving""x: übelappende Bänderc: closedd: diamondss: Schleifchenz: zickzackr: Ringe"^ #(#('+1a' '+1b' '+1a' '+1b')    "1" "+++ 2..4 c z"#('+1a' '+1a' '+1a' '+2a')    "2" "3"#('+1a' '+1a' '+1a' '+3a')    "3"#('+1a' '+1a' '+1a' '+4a')    "4"#('+1c' '+1c' '+1a' '-4b')    "5"#('+1a' '+1a' '+1a' '-3a')    "6" "+"#('+1c' '+1c' '+1a' '-2b')    "7"#('+1a' '+1a' '+1a' '-1a')    "8"#('+1a' '+1a' '+2a' '+2a')    "9"#('+1a' '+1a' '+2a' '+3a')   "10"#('+1a' '+1a' '+2a' '+4a')   "11" "+"#('+1b' '+1a' '+2a' '-4b')   "12" "+"#('+1a' '+1a' '+2a' '-3a')   "13" "+"#('+1a' '+1a' '+2a' '-2a')   "14"#('+1a' '+1a' '+2a' '-1a')   "15" "+"#('+1a' '+1a' '+3a' '+3a')   "16"#('+1a' '+1a' '+3a' '+4a')   "17" "+ 1..5 x"#('+1a' '+1a' '+3a' '-4a')   "18"#('+1b' '+1a' '+3a' '-3a')   "19" "+ 4..8 s "#('+1a' '+1a' '+3a' '-2a')   "20" "+ 1..5 d=4"#('+1a' '+1a' '+3a' '-1a')   "21" "+ 1..9 d=8"#('+1a' '+1a' '+4a' '+4a')   "22"#('+1a' '+1b' '+4d' '-4a')   "23" "+ 2..8 s"#('+1a' '+1a' '+4a' '-3a')   "24"#('+1a' '+1a' '+4a' '-2a')   "25"#('+1a' '+1a' '+4a' '-1a')   "26"#('+1a' '+1a' '-4a' '-4a')   "27"#('+1b' '+1a' '-4d' '-3a')   "28" "++ 2..8 x s"#('+1b' '+1a' '-4a' '-2b')   "29" "++ 1..5 d=4"#('+1a' '+1b' '-4b' '-1a')   "30"#('+1b' '+1a' '-3a' '-3b')   "31" "+++ 2..4 c"#('+1b' '+1a' '-3a' '-2b')   "32" "++ 3..4 s"#('+1a' '+1a' '-3a' '-1a')   "33"#('+1a' '+1a' '-2a' '-2a')   "34"#('+1a' '+1a' '-2a' '-1a')   "35"#('+1d' '+1d' '-1d' '-1d')   "36" "++ 2..12 c d=8"#('+1a' '+2a' '+1a' '+3a')   "37" "+ 6..6 s"#('+1a' '+2b' '+1c' '+4a')   "38" "++ 2..2 x c"#('+1a' '+2b' '+1c' '-4a')   "39" "+++ 4..14 c"#('+1a' '+2a' '+1a' '-3a')   "40"#('+1a' '+2a' '+1a' '-2a')   "41"#('+1a' '+2a' '+1a' '-1a')   "42"#('+1b' '+2c' '+2d' '+1a')   "43" "++ 5..8 c"#('+1a' '+2a' '+2a' '+3a')   "44"#('+1a' '+2a' '+2a' '+4a')   "45"#('+1a' '+2a' '+2a' '-4a')   "46"#('+1a' '+2b' '+2b' '-3a')   "47" "+ c"#('+1a' '+2a' '+2a' '-2a')   "48"#('+1a' '+2a' '+2a' '-1a')   "49"#('+1a' '+2b' '+3b' '+1a')   "50" "+ 8..8 s lange Stränge"#('+1a' '+2a' '+3a' '+4a')   "51"#('+1a' '+2d' '+3b' '-4a')   "52" "++ 2..2 s"#('+1b' '+2a' '+3a' '-3d')   "53" "++ 2..9 x s"#('+1a' '+2a' '+3a' '-2a')   "54"#('+1b' '+2c' '+3a' '-1b')   "55" "++ 2..5 s d=4 "#('+1a' '+2d' '+4d' '+3a')   "56" "++ 5..205 d=100 r=100"#('+1a' '+2a' '+4a' '-4a')   "57"#('+1a' '+2a' '+4a' '-3a')   "58"#('+1d' '+2a' '+4a' '-2b')   "59" "++ 2..9 s d=4 r=4"#('+1c' '+2d' '+4b' '-1a')   "60" "++ 1..5 x d=4"#('+1d' '+2a' '-4a' '+1b')   "61" "+ 5..72 loses Band"#('+1a' '+2b' '-4c' '+4a')   "62" "+ 2..2 x s"#('+1b' '+2a' '-4a' '-4a')   "63" "+ 5..16 s"#('+1d' '+2a' '-4a' '-3d')   "64" "+ 2..2 x s"#('+1d' '+2c' '-4a' '-2d')   "65" "+"#('+1c' '+2b' '-4c' '-1c')   "66" "+++ 3..12 d=8"#('+1b' '+2c' '-3b' '+1a')   "67" "+"#('+1a' '+2b' '-3a' '+4b')   "68" "++  3 c"#('+1a' '+2d' '-3b' '-4c')   "69" "+++ 2 c"#('+1a' '+2a' '-3a' '-2a')   "70" "+"#('+1a' '+2a' '-3a' '-1a')   "71"#('+1b' '+2c' '-2a' '+1d')   "72" "+ 4..14 c  abaa bcaa"#('+1b' '+2c' '-2b' '+4a')   "73"#('+1b' '+2c' '-2c' '-4a')   "74" "+ 2..2 x s hoch"#('+1b' '+2c' '-2a' '-3c')   "75" "+ 3..6 x"#('+1b' '+2c' '-2c' '-2d')   "76"#('+1a' '+2d' '-2d' '-1a')   "77"#('+1b' '+2c' '-1a' '+1a')   "78"#('+1b' '+2c' '-1a' '+4d')   "79" "+ 2..2 s"#('+1a' '+2d' '-1b' '-4a')   "80"#('+1a' '+2a' '-1a' '-3a')   "81"#('+1a' '+2d' '-1c' '-2b')   "82" "++ S.479"#('+1a' '+3b' '+1a' '+3b')   "83" "+++ 2..4 c z (151 nebeneinander)"#('+1b' '+3a' '+1b' '+4b')   "84" "++ 8..16 s"#('+1a' '+3a' '+1a' '-4a')   "85"#('+1a' '+3a' '+1a' '-3b')   "86" "+ 2..4 s"#('+1a' '+3b' '+1a' '-2a')   "87" "+++ 4..8 s ganz lange Bänder"#('+1a' '+3b' '+1a' '-1b')   "88" "++++ 3..4 x c z (102)"#('+1b' '+3a' '+2b' '+4a')   "89" "+ 5..105 freie Bändchen"#('+1a' '+3b' '+2b' '-4c')   "90"#('+1a' '+3a' '+2a' '-3a')   "91"#('+1a' '+3b' '+2c' '-2d')   "92" "++ 4..4 x"#('+1a' '+3a' '+2a' '-1a')   "93"#('+1b' '+3a' '+3a' '+1b')   "94" "++ 3..8 c"#('+1a' '+3a' '+3a' '-4a')   "95"#('+1a' '+3a' '+3a' '-3a')   "96"#('+1a' '+3a' '+3a' '-2a')   "97"#('+1a' '+3b' '+3d' '-1c')   "98" "+ 2..2 x s"#('+1b' '+3b' '-4d' '-4c')   "99" "++ 4..14 c"#('+1a' '+3c' '-4b' '-2c')  "100" "+ 2..5 x s"#('+1a' '+3a' '-4a' '-1a')  "101" "+ 3..6 x s"#('+1a' '+3b' '-3a' '-1b')  "102" "++++ 4..4 c z (88)"#('+1a' '+3a' '-2a' '-4a')  "103"#('+1a' '+3a' '-2a' '-3a')  "104"#('+1a' '+3a' '-1a' '-3a')  "105"#('+1b' '+4a' '+1a' '-4d')  "106" "+ 2..5"#('+1a' '+4a' '+1a' '-3a')  "107"#('+1c' '+4a' '+1a' '-2b')  "108" "++ 4..10 c"#('+1a' '+4a' '+1a' '-1a')  "109"#('+1c' '+4b' '+2c' '+3b')  "110" "++ 5..105 c d=100 Hakenkreuz"#('+1b' '+4c' '+2a' '-4d')  "111" "+ 1..5 x s d=4"#('+1b' '+4a' '+2a' '-3b')  "112"#('+1a' '+4a' '+2a' '-2a')  "113"#('+1b' '+4c' '+2b' '-1a')  "114" "+ 3..12 x d=8"#('+1a' '+4a' '+3a' '-4a')  "115"#('+1a' '+4a' '+3a' '-3a')  "116" "+ 6..20 s"#('+1a' '+4a' '+3a' '-2a')  "117"#('+1a' '+4b' '+3b' '-1a')  "118" "++ 1..5 s"#('+1a' '+4a' '-4a' '-4a')  "119"#('+1a' '+4a' '-4a' '-2a')  "120"#('+1a' '+4a' '-4a' '-1a')  "121"#('+1d' '+4b' '-3c' '-2a')  "122" "+++ 3..6 c"#('+1b' '+4a' '-2a' '-4b')  "123"#('+1a' '+4a' '-2a' '-3a')  "124"#('+1a' '+4a' '-2a' '-2a')  "125"#('+1a' '+4a' '-1b' '-4b')  "126" "+ 3..10 d=6"#('+1c' '-4a' '-4c' '+1b')  "127" "++ 2..4 c"#('+1a' '-4a' '-4a' '+2a')  "128"#('+1a' '-4a' '-4a' '+3a')  "129"#('+1d' '-4b' '-4a' '+4a')  "130" "+ 2..10 x s r=8 grosse Ringe"#('+1d' '-4d' '-3d' '+2d')  "131" "++ 2..2 c"#('+1a' '-4a' '-3a' '+3a')  "132"#('+1a' '-4a' '-3a' '+4a')  "133"#('+1a' '-4a' '-2a' '+2a')  "134"#('+1c' '-4a' '-2c' '+3b')  "135" "+ 3..24 d=16"#('+1a' '-4a' '-2a' '+4a')  "136"#('+1a' '-4a' '-1a' '+2a')  "137"#('+1a' '-4a' '-1a' '+3a')  "138" " 2..8 x s d=4"#('+1d' '-4b' '-1a' '+4d')  "139" "++ 3..12 c d=4"#('+1a' '-3b' '+1b' '-3a')  "140" "++ 2..8 c"#('+1a' '-3a' '+1a' '-1a')  "141"#('+1a' '-3a' '+3b' '-1b')  "142" "+++ 3..20 d=14"#('+1b' '-3a' '-3b' '+1a')  "143" "++ 3..12 z c r=8 kites"#('+1a' '-3b' '-3a' '+3a')  "144" "+ Schleifchen"#('+1a' '-3a' '-3a' '+4a')  "145"#('+1a' '-3a' '-2a' '+4a')  "146"#('+1a' '-3a' '-1a' '+3a')  "147" "+"#('+1d' '-2a' '-3a' '+4b')  "148" "++ 2..10 c"#('+1a' '-2b' '-2d' '+1a')  "149" "++ 3..10 c"#('+1a' '-2a' '-2a' '+4a')  "150"#('+1a' '-1b' '+1a' '-1b')  "151" "++++ 2..8 c z (83 nebeneinander)"#('+1b' '-1b' '+3c' '-3a')  "152" "++ 4..4 c"#('+1b' '-1a' '-3b' '+3a')  "153" "+++ 4..4 c z"#('+1b' '-1a' '-1a' '+1b')  "154" "++ 2..8 c z").! !!ETileBigRoassal class methodsFor: 'constants' stamp: 'PeterGraf 3/9/2024 10:20'!tileStanWagonSizes154"154 Zeilen und Spalten, damit BigTileRoassal eine Fliese ist."" minRow minColumn"^ #(#(4 4)     "1"#(4 4)     "2"#(16 16)   "3"#(16 8)    "4"#(4 4)     "5"  "8 8" "8 colors needed, me: 2"#(4 4)     "6" "8 4"#(12 4)    "7" "12 4"#(4 4)     "8"#(8 16)    "9"#(16 8)   "10"#(8 16)   "11"#(4 8)    "12"#(12 12)  "13"#(12 4)   "14"#(4 4)    "15"#(12 12)  "16"#(4 4)    "17"  "1 color?"#(4 8)    "18"#(16 8)   "19"#(4 4)    "20"#(4 4)    "21"#(4 8)    "22"#(4 8)    "23"#(4 8)    "24"#(8 4)    "25"#(8 4)    "26"#(8 4)    "27"#(8 4)    "28"#(4 4)    "29"#(4 4)    "30"#(4 4)    "31"#(8 4)    "32" "+"#(8 4)    "33"#(8 4)    "34"#(8 4)    "35"#(4 4)    "36"#(24 12)  "37"   "longest"#(16 4)   "38"#(8 4)    "39"#(4 4)    "40"#(4 4)    "41"#(12 4)   "42"#(16 16)  "43"#(8 8)    "44"#(20 20)  "45"   "interesting"#(4 4)    "46"#(8 4)    "47"#(8 4)    "48"#(8 8)    "49"#(8 16)   "50"#(8 16)   "51"#(4 12)   "52"#(8 8)    "53"#(8 4)    "54"#(4 4)    "55"#(20 20)  "56"    "55 colors?"#(8 8)    "57"#(4 8)    "58"#(4 4)    "59"#(4 4)    "60"  "++ 1 very interesting connectivity"#(16 16)  "61"#(12 4)   "62"#(16 16)  "63"#(8 4)    "64"#(8 4)    "65"#(8 4)    "66"#(8 4)    "67"#(12 12)  "68"#(8 4)    "69"#(8 4)    "70"#(8 4)    "71"#(8 4)    "72"#(8 4)    "73"#(16 4)   "74"#(4 8)    "75"#(8 4)    "76"#(8 4)    "77"#(16 16)  "78"#(8 4)    "79"#(8 8)    "80"#(8 4)    "81"#(4 8)    "82" "8 4"#(4 4)    "83"#(16 16)  "84"  "8 colors needed; a beauty"#(12 4)   "85"#(4 4)    "86"#(16 16)  "87"#(4 12)   "88"#(20 20)  "89"#(4 4)    "90"#(8 4)    "91"#(8 16)   "92"#(4 16)   "93"#(8 8)    "94"#(4 8)    "95"#(4 12)   "96"#(4 8)    "97"#(4 8)    "98"#(4 8)    "99"#(4 4)   "100"#(8 4)   "101"#(4 8)   "102"#(8 4)   "103"#(8 4)   "104"#(4 4)   "105"#(4 4)   "106"#(12 4)  "107"#(8 4)   "108"#(8 8)   "109"#(20 20) "110"#(4 4)   "111"#(12 4)  "112"#(8 4)   "113"#(4 8)   "114"#(4 8)   "115"#(20 20) "116"#(16 16) "117"#(4 4)   "118"#(4 4)   "119"#(16 16) "120"#(4 4)   "121"#(4 4)   "122"#(8 4)   "123"#(8 4)   "124"#(8 4)   "125"#(4 4)   "126"#(8 8)   "127"#(4 4)   "128"#(4 4)   "129"#(8 4)   "130"#(8 4)   "131"#(12 4)  "132"#(4 8)   "133"#(16 4)  "134"#(8 8)   "135"#(4 4)   "136"#(4 4)   "137"#(4 4)   "138"#(4 4)   "139"#(4 4)   "140"#(8 4)   "141"#(4 8)   "142"#(4 4)   "143"#(4 4)   "144"#(4 4)   "145"#(4 4)   "146"#(4 4)   "147"#(4 12)  "148"#(4 4)   "149"#(8 4)   "150"#(4 4)   "151"#(4 8)   "152"#(4 8)   "153"#(4 4)   "154").! !!ETileBigRoassal class methodsFor: 'constants' stamp: 'PeterGraf 2/20/2024 14:34'!tile3x3Sizes154"154 Zeilen und Spalten, damit BigTileRoassal eine Fliese ist."" minRow minColumn"^ #(#(3 3)     "1"#(3 3)     "2" "4 4"#(3 3)   "3"#(3 3)    "4"#(3 3)     "5"  "8 8" "8 colors needed 2"#(3 3)     "6" "8 4"#(3 3)    "7" "12 4"#(3 3)     "8"#(3 3)    "9"#(3 3)   "10"#(3 3)   "11"#(3 3)    "12"#(3 3)  "13"#(3 3)   "14"#(3 3)    "15"#(3 3)  "16"#(3 3)    "17"  "1 color?"#(3 3)    "18"#(3 3)   "19"#(3 3)    "20"#(3 3)    "21"#(3 3)    "22"#(3 3)    "23"#(3 3)    "24"#(3 3)    "25"#(3 3)    "26"#(3 3)    "27"#(3 3)    "28"#(3 3)    "29"#(3 3)    "30"#(3 3)    "31"#(3 3)    "32" "+"#(3 3)    "33"#(3 3)    "34"#(3 3)    "35"#(3 3)    "36"#(3 3)  "37"   "longest"#(3 3)   "38"#(3 3)    "39"#(3 3)    "40"#(3 3)    "41"#(3 3)   "42"#(3 3)  "43"#(3 3)    "44"#(3 3)  "45"   "interesting"#(3 3)    "46"#(3 3)    "47"#(3 3)    "48"#(3 3)    "49"#(3 3)   "50"#(3 3)   "51"#(3 3)   "52"#(3 3)    "53"#(3 3)    "54"#(3 3)    "55"#(3 3)  "56"    "55 colors?"#(3 3)    "57"#(3 3)    "58"#(3 3)    "59"#(3 3)    "60"  "++ 1 very interesting connectivity"#(3 3)  "61"#(3 3)   "62"#(3 3)  "63"#(3 3)    "64"#(3 3)    "65"#(3 3)    "66"#(3 3)    "67"#(3 3)  "68"#(3 3)    "69"#(3 3)    "70"#(3 3)    "71"#(3 3)    "72"#(3 3)    "73"#(3 3)   "74"#(3 3)    "75"#(3 3)    "76"#(3 3)    "77"#(3 3)  "78"#(3 3)    "79"#(3 3)    "80"#(3 3)    "81"#(3 3)    "82" "8 4"#(3 3)    "83"#(3 3)  "84"  "8 colors needed; a beauty"#(3 3)   "85"#(3 3)    "86"#(3 3)  "87"#(3 3)   "88"#(3 3)  "89"#(3 3)    "90"#(3 3)    "91"#(3 3)   "92"#(3 3)   "93"#(3 3)    "94"#(3 3)    "95"#(3 3)   "96"#(3 3)    "97"#(3 3)    "98"#(3 3)    "99"#(3 3)   "100"#(3 3)   "101"#(3 3)   "102"#(3 3)   "103"#(3 3)   "104"#(3 3)   "105"#(3 3)   "106"#(3 3)  "107"#(3 3)   "108"#(3 3)   "109"#(3 3) "110"#(3 3)   "111"#(3 3)  "112"#(3 3)   "113"#(3 3)   "114"#(3 3)   "115"#(3 3) "116"#(3 3) "117"#(3 3)   "118"#(3 3)   "119"#(3 3) "120"#(3 3)   "121"#(3 3)   "122"#(3 3)   "123"#(3 3)   "124"#(3 3)   "125"#(3 3)   "126"#(3 3)   "127"#(3 3)   "128"#(3 3)   "129"#(3 3)   "130"#(3 3)   "131"#(3 3)  "132"#(3 3)   "133"#(3 3)  "134"#(3 3)   "135"#(3 3)   "136"#(3 3)   "137"#(3 3)   "138"#(3 3)   "139"#(3 3)   "140"#(3 3)   "141"#(3 3)   "142"#(3 3)   "143"#(3 3)   "144"#(3 3)   "145"#(3 3)   "146"#(3 3)   "147"#(3 3)  "148"#(3 3)   "149"#(3 3)   "150"#(3 3)   "151"#(3 3)   "152"#(3 3)   "153"#(3 3)   "154").! !!ETileBigRoassal class methodsFor: 'constants' stamp: 'PeterGraf 2/20/2024 14:33'!tile2x2Sizes154"154 Zeilen und Spalten, damit BigTileRoassal eine Fliese ist."" minRow minColumn"^ #(#(2 2)     "1"#(2 2)     "2" "4 4"#(2 2)   "3"#(2 2)    "4"#(2 2)     "5"  "8 8" "8 colors needed 2"#(2 2)     "6" "8 4"#(2 2)    "7" "12 4"#(2 2)     "8"#(2 2)    "9"#(2 2)   "10"#(2 2)   "11"#(2 2)    "12"#(2 2)  "13"#(2 2)   "14"#(2 2)    "15"#(2 2)  "16"#(2 2)    "17"  "1 color?"#(2 2)    "18"#(2 2)   "19"#(2 2)    "20"#(2 2)    "21"#(2 2)    "22"#(2 2)    "23"#(2 2)    "24"#(2 2)    "25"#(2 2)    "26"#(2 2)    "27"#(2 2)    "28"#(2 2)    "29"#(2 2)    "30"#(2 2)    "31"#(2 2)    "32" "+"#(2 2)    "33"#(2 2)    "34"#(2 2)    "35"#(2 2)    "36"#(2 2)  "37"   "longest"#(2 2)   "38"#(2 2)    "39"#(2 2)    "40"#(2 2)    "41"#(2 2)   "42"#(2 2)  "43"#(2 2)    "44"#(2 2)  "45"   "interesting"#(2 2)    "46"#(2 2)    "47"#(2 2)    "48"#(2 2)    "49"#(2 2)   "50"#(2 2)   "51"#(2 2)   "52"#(2 2)    "53"#(2 2)    "54"#(2 2)    "55"#(2 2)  "56"    "55 colors?"#(2 2)    "57"#(2 2)    "58"#(2 2)    "59"#(2 2)    "60"  "++ 1 very interesting connectivity"#(2 2)  "61"#(2 2)   "62"#(2 2)  "63"#(2 2)    "64"#(2 2)    "65"#(2 2)    "66"#(2 2)    "67"#(2 2)  "68"#(2 2)    "69"#(2 2)    "70"#(2 2)    "71"#(2 2)    "72"#(2 2)    "73"#(2 2)   "74"#(2 2)    "75"#(2 2)    "76"#(2 2)    "77"#(2 2)  "78"#(2 2)    "79"#(2 2)    "80"#(2 2)    "81"#(2 2)    "82" "8 4"#(2 2)    "83"#(2 2)  "84"  "8 colors needed; a beauty"#(2 2)   "85"#(2 2)    "86"#(2 2)  "87"#(2 2)   "88"#(2 2)  "89"#(2 2)    "90"#(2 2)    "91"#(2 2)   "92"#(2 2)   "93"#(2 2)    "94"#(2 2)    "95"#(2 2)   "96"#(2 2)    "97"#(2 2)    "98"#(2 2)    "99"#(2 2)   "100"#(2 2)   "101"#(2 2)   "102"#(2 2)   "103"#(2 2)   "104"#(2 2)   "105"#(2 2)   "106"#(2 2)  "107"#(2 2)   "108"#(2 2)   "109"#(2 2) "110"#(2 2)   "111"#(2 2)  "112"#(2 2)   "113"#(2 2)   "114"#(2 2)   "115"#(2 2) "116"#(2 2) "117"#(2 2)   "118"#(2 2)   "119"#(2 2) "120"#(2 2)   "121"#(2 2)   "122"#(2 2)   "123"#(2 2)   "124"#(2 2)   "125"#(2 2)   "126"#(2 2)   "127"#(2 2)   "128"#(2 2)   "129"#(2 2)   "130"#(2 2)   "131"#(2 2)  "132"#(2 2)   "133"#(2 2)  "134"#(2 2)   "135"#(2 2)   "136"#(2 2)   "137"#(2 2)   "138"#(2 2)   "139"#(2 2)   "140"#(2 2)   "141"#(2 2)   "142"#(2 2)   "143"#(2 2)   "144"#(2 2)   "145"#(2 2)   "146"#(2 2)   "147"#(2 2)  "148"#(2 2)   "149"#(2 2)   "150"#(2 2)   "151"#(2 2)   "152"#(2 2)   "153"#(2 2)   "154").! !!ETileBigRoassal class methodsFor: 'constants' stamp: 'PeterGraf 2/20/2024 19:39'!tile8x8Sizes154"154 Zeilen und Spalten, damit BigTileRoassal eine Fliese ist."" minRow minColumn"^ #(#(8 8)     "1"#(8 8)     "2" "4 4"#(8 8)   "3"#(8 8)    "4"#(8 8)     "5"  "8 8" "8 colors needed 2"#(8 8)     "6" "8 4"#(8 8)    "7" "12 4"#(8 8)     "8"#(8 8)    "9"#(8 8)   "10"#(8 8)   "11"#(8 8)    "12"#(8 8)  "13"#(8 8)   "14"#(8 8)    "15"#(8 8)  "16"#(8 8)    "17"  "1 color?"#(8 8)    "18"#(8 8)   "19"#(8 8)    "20"#(8 8)    "21"#(8 8)    "22"#(8 8)    "23"#(8 8)    "24"#(8 8)    "25"#(8 8)    "26"#(8 8)    "27"#(8 8)    "28"#(8 8)    "29"#(8 8)    "30"#(8 8)    "31"#(8 8)    "32" "+"#(8 8)    "33"#(8 8)    "34"#(8 8)    "35"#(8 8)    "36"#(8 8)  "37"   "longest"#(8 8)   "38"#(8 8)    "39"#(8 8)    "40"#(8 8)    "41"#(8 8)   "42"#(8 8)  "43"#(8 8)    "44"#(8 8)  "45"   "interesting"#(8 8)    "46"#(8 8)    "47"#(8 8)    "48"#(8 8)    "49"#(8 8)   "50"#(8 8)   "51"#(8 8)   "52"#(8 8)    "53"#(8 8)    "54"#(8 8)    "55"#(8 8)  "56"    "55 colors?"#(8 8)    "57"#(8 8)    "58"#(8 8)    "59"#(8 8)    "60"  "++ 1 very interesting connectivity"#(8 8)  "61"#(8 8)   "62"#(8 8)  "63"#(8 8)    "64"#(8 8)    "65"#(8 8)    "66"#(8 8)    "67"#(8 8)  "68"#(8 8)    "69"#(8 8)    "70"#(8 8)    "71"#(8 8)    "72"#(8 8)    "73"#(8 8)   "74"#(8 8)    "75"#(8 8)    "76"#(8 8)    "77"#(8 8)  "78"#(8 8)    "79"#(8 8)    "80"#(8 8)    "81"#(8 8)    "82" "8 4"#(8 8)    "83"#(8 8)  "84"  "8 colors needed; a beauty"#(8 8)   "85"#(8 8)    "86"#(8 8)  "87"#(8 8)   "88"#(8 8)  "89"#(8 8)    "90"#(8 8)    "91"#(8 8)   "92"#(8 8)   "93"#(8 8)    "94"#(8 8)    "95"#(8 8)   "96"#(8 8)    "97"#(8 8)    "98"#(8 8)    "99"#(8 8)   "100"#(8 8)   "101"#(8 8)   "102"#(8 8)   "103"#(8 8)   "104"#(8 8)   "105"#(8 8)   "106"#(8 8)  "107"#(8 8)   "108"#(8 8)   "109"#(8 8) "110"#(8 8)   "111"#(8 8)  "112"#(8 8)   "113"#(8 8)   "114"#(8 8)   "115"#(8 8) "116"#(8 8) "117"#(8 8)   "118"#(8 8)   "119"#(8 8) "120"#(8 8)   "121"#(8 8)   "122"#(8 8)   "123"#(8 8)   "124"#(8 8)   "125"#(8 8)   "126"#(8 8)   "127"#(8 8)   "128"#(8 8)   "129"#(8 8)   "130"#(8 8)   "131"#(8 8)  "132"#(8 8)   "133"#(8 8)  "134"#(8 8)   "135"#(8 8)   "136"#(8 8)   "137"#(8 8)   "138"#(8 8)   "139"#(8 8)   "140"#(8 8)   "141"#(8 8)   "142"#(8 8)   "143"#(8 8)   "144"#(8 8)   "145"#(8 8)   "146"#(8 8)   "147"#(8 8)  "148"#(8 8)   "149"#(8 8)   "150"#(8 8)   "151"#(8 8)   "152"#(8 8)   "153"#(8 8)   "154").! !!ETileBigRoassal class methodsFor: 'as yet unclassified' stamp: 'PeterGraf 3/9/2024 10:29'!defaultWeavingStringsAt: index	" ^	#( 'abcd' 'abab' 'cdcd' ) "^#(#( 'abab' ) "1"#( 'aaaa' ) "2"#( 'aaaa' ) "3"#( 'aaaa' ) "4"#( 'ccab' ) "5"#( 'aaaa' ) "6"#( 'ccab' ) "7"#( 'aaaa' ) "8"#( 'aaaa' ) "9"#( 'aaaa' ) "10"#( 'aaaa' ) "11"#( 'baab' ) "12"#( 'aaaa' ) "13"#( 'aaaa' ) "14"#( 'aaaa' ) "15"#( 'aaaa' ) "16"#( 'aaaa' ) "17"#( 'aaaa' ) "18"#( 'baaa' ) "19"#( 'aaaa' ) "20"#( 'aaaa' ) "21"#( 'aaaa' ) "22"#( 'abda' ) "23"#( 'aaaa' ) "24"#( 'aaaa' ) "25"#( 'aaaa' ) "26"#( 'aaaa' ) "27"#( 'bada' ) "28"#( 'baab' ) "29"#( 'abba' ) "30"#( 'baab' ) "31"#( 'baab' ) "32"#( 'aaaa' ) "33"#( 'aaaa' ) "34"#( 'aaaa' ) "35"#( 'dddd' ) "36"#( 'aaaa' ) "37"#( 'abca' ) "38"#( 'abca' ) "39"#( 'aaaa' ) "40"#( 'aaaa' ) "41"#( 'aaaa' ) "42"#( 'bcda' ) "43"#( 'aaaa' ) "44"#( 'aaaa' ) "45"#( 'aaaa' ) "46"#( 'abba' ) "47"#( 'aaaa' ) "48"#( 'aaaa' ) "49"#( 'abba' ) "50"#( 'aaaa' ) "51"#( 'adba' ) "52"#( 'baad' ) "53"#( 'aaaa' ) "54"#( 'bcab' ) "55"#( 'adda' ) "56"#( 'aaaa' ) "57"#( 'aaaa' ) "58"#( 'daab' ) "59"#( 'cbda' ) "60"#( 'daab' ) "61"#( 'bcaa' ) "62"#( 'baaa' ) "63"#( 'daad' ) "64"#( 'dcad' ) "65"#( 'cbcc' ) "66"#( 'bcba' ) "67"#( 'abab' ) "68"#( 'adbc' ) "69"#( 'aaaa' ) "70"#( 'aaaa' ) "71"#( 'bcca' ) "72"#( 'bcba' ) "73"#( 'bcca' ) "74"#( 'bcac' ) "75"#( 'bccd' ) "76"#( 'adda' ) "77"#( 'bcaa' ) "78"#( 'bcad' ) "79"#( 'adba' ) "80"#( 'aaaa' ) "81"#( 'adcb' ) "82"#( 'abab' ) "83"#( 'babb' ) "84"#( 'aaaa' ) "85"#( 'aaab' ) "86"#( 'abaa' ) "87"#( 'abab' ) "88"#( 'baba' ) "89"#( 'abbc' ) "90"#( 'aaaa' ) "91"#( 'abcd' ) "92"#( 'aaaa' ) "93"#( 'baab' ) "94"#( 'aaaa' ) "95"#( 'aaaa' ) "96"#( 'aaaa' ) "97"#( 'abdc' ) "98"#( 'bbdc' ) "99"#( 'acbc' ) "100"#( 'aaaa' ) "101"#( 'abab' ) "102"#( 'aaaa' ) "103"#( 'aaaa' ) "104"#( 'aaaa' ) "105"#( 'baad' ) "106"#( 'aaaa' ) "107"#( 'caab' ) "108"#( 'aaaa' ) "109"#( 'cbcb' ) "110"#( 'bcad' ) "111"#( 'baab' ) "112"#( 'aaaa' ) "113"#( 'bcba' ) "114"#( 'aaaa' ) "115"#( 'aaaa' ) "116"#( 'aaaa' ) "117"#( 'abba' ) "118"#( 'aaaa' ) "119"#( 'aaaa' ) "120"#( 'aaaa' ) "121"#( 'dbca' ) "122"#( 'baab' ) "123"#( 'aaaa' ) "124"#( 'aaaa' ) "125"#( 'aabb' ) "126"#( 'cccc' ) "127"#( 'aaaa' ) "128"#( 'aaaa' ) "129"#( 'dbaa' ) "130"#( 'dddd' ) "131"#( 'aaaa' ) "132"#( 'aaaa' ) "133"#( 'aaaa' ) "134"#( 'cacb' ) "135"#( 'aaaa' ) "136"#( 'aaaa' ) "137"#( 'aaaa' ) "138"#( 'dbad' ) "139"#( 'abba' ) "140"#( 'aaaa' ) "141"#( 'aabb' ) "142"#( 'baba' ) "143"#( 'abaa' ) "144"#( 'aaaa' ) "145"#( 'aaaa' ) "146"#( 'aaaa' ) "147"#( 'daab' ) "148"#( 'abda' ) "149"#( 'aaaa' ) "150"#( 'abab' ) "151"#( 'bbca' ) "152"#( 'baba' ) "153"#( 'baab' ) "154") at: (index beBetween: 1 and: 154)! !!ETileBigRoassal class methodsFor: 'as yet unclassified' stamp: 'PeterGraf 2/20/2024 13:59'!fileExtensionFromStringHowTo: aName	^	aName asFileReference extension asLowercase! !!ETileBigRoassal class methodsFor: 'as yet unclassified' stamp: 'PeterGraf 2/20/2024 14:01'!fourPattern2StringsAt: index	"^	#('+1' '+2' '+3' '+4')"^#(#( '+1' '+1' '+1' '+1' ) "1"#( '+1' '+1' '+1' '+2' ) "2"#( '+1' '+1' '+1' '+3' ) "3"#( '+1' '+1' '+1' '+4' ) "4"#( '+1' '+1' '+1' '-4' ) "5"#( '+1' '+1' '+1' '-3' ) "6"#( '+1' '+1' '+1' '-2' ) "7"#( '+1' '+1' '+1' '-1' ) "8"#( '+1' '+1' '+2' '+2' ) "9"#( '+1' '+1' '+2' '+3' ) "10"#( '+1' '+1' '+2' '+4' ) "11"#( '+1' '+1' '+2' '-4' ) "12"#( '+1' '+1' '+2' '-3' ) "13"#( '+1' '+1' '+2' '-2' ) "14"#( '+1' '+1' '+2' '-1' ) "15"#( '+1' '+1' '+3' '+3' ) "16"#( '+1' '+1' '+3' '+4' ) "17"#( '+1' '+1' '+3' '-4' ) "18"#( '+1' '+1' '+3' '-3' ) "19"#( '+1' '+1' '+3' '-2' ) "20"#( '+1' '+1' '+3' '-1' ) "21"#( '+1' '+1' '+4' '+4' ) "22"#( '+1' '+1' '+4' '-4' ) "23"#( '+1' '+1' '+4' '-3' ) "24"#( '+1' '+1' '+4' '-2' ) "25"#( '+1' '+1' '+4' '-1' ) "26"#( '+1' '+1' '-4' '-4' ) "27"#( '+1' '+1' '-4' '-3' ) "28"#( '+1' '+1' '-4' '-2' ) "29"#( '+1' '+1' '-4' '-1' ) "30"#( '+1' '+1' '-3' '-3' ) "31"#( '+1' '+1' '-3' '-2' ) "32"#( '+1' '+1' '-3' '-1' ) "33"#( '+1' '+1' '-2' '-2' ) "34"#( '+1' '+1' '-2' '-1' ) "35"#( '+1' '+1' '-1' '-1' ) "36"#( '+1' '+2' '+1' '+3' ) "37"#( '+1' '+2' '+1' '+4' ) "38"#( '+1' '+2' '+1' '-4' ) "39"#( '+1' '+2' '+1' '-3' ) "40"#( '+1' '+2' '+1' '-2' ) "41"#( '+1' '+2' '+1' '-1' ) "42"#( '+1' '+2' '+2' '+1' ) "43"#( '+1' '+2' '+2' '+3' ) "44"#( '+1' '+2' '+2' '+4' ) "45"#( '+1' '+2' '+2' '-4' ) "46"#( '+1' '+2' '+2' '-3' ) "47"#( '+1' '+2' '+2' '-2' ) "48"#( '+1' '+2' '+2' '-1' ) "49"#( '+1' '+2' '+3' '+1' ) "50"#( '+1' '+2' '+3' '+4' ) "51"#( '+1' '+2' '+3' '-4' ) "52"#( '+1' '+2' '+3' '-3' ) "53"#( '+1' '+2' '+3' '-2' ) "54"#( '+1' '+2' '+3' '-1' ) "55"#( '+1' '+2' '+4' '+3' ) "56"#( '+1' '+2' '+4' '-4' ) "57"#( '+1' '+2' '+4' '-3' ) "58"#( '+1' '+2' '+4' '-2' ) "59"#( '+1' '+2' '+4' '-1' ) "60"#( '+1' '+2' '-4' '+1' ) "61"#( '+1' '+2' '-4' '+4' ) "62"#( '+1' '+2' '-4' '-4' ) "63"#( '+1' '+2' '-4' '-3' ) "64"#( '+1' '+2' '-4' '-2' ) "65"#( '+1' '+2' '-4' '-1' ) "66"#( '+1' '+2' '-3' '+1' ) "67"#( '+1' '+2' '-3' '+4' ) "68"#( '+1' '+2' '-3' '-4' ) "69"#( '+1' '+2' '-3' '-2' ) "70"#( '+1' '+2' '-3' '-1' ) "71"#( '+1' '+2' '-2' '+1' ) "72"#( '+1' '+2' '-2' '+4' ) "73"#( '+1' '+2' '-2' '-4' ) "74"#( '+1' '+2' '-2' '-3' ) "75"#( '+1' '+2' '-2' '-2' ) "76"#( '+1' '+2' '-2' '-1' ) "77"#( '+1' '+2' '-1' '+1' ) "78"#( '+1' '+2' '-1' '+4' ) "79"#( '+1' '+2' '-1' '-4' ) "80"#( '+1' '+2' '-1' '-3' ) "81"#( '+1' '+2' '-1' '-2' ) "82"#( '+1' '+3' '+1' '+3' ) "83"#( '+1' '+3' '+1' '+4' ) "84"#( '+1' '+3' '+1' '-4' ) "85"#( '+1' '+3' '+1' '-3' ) "86"#( '+1' '+3' '+1' '-2' ) "87"#( '+1' '+3' '+1' '-1' ) "88"#( '+1' '+3' '+2' '+4' ) "89"#( '+1' '+3' '+2' '-4' ) "90"#( '+1' '+3' '+2' '-3' ) "91"#( '+1' '+3' '+2' '-2' ) "92"#( '+1' '+3' '+2' '-1' ) "93"#( '+1' '+3' '+3' '+1' ) "94"#( '+1' '+3' '+3' '-4' ) "95"#( '+1' '+3' '+3' '-3' ) "96"#( '+1' '+3' '+3' '-2' ) "97"#( '+1' '+3' '+3' '-1' ) "98"#( '+1' '+3' '-4' '-4' ) "99"#( '+1' '+3' '-4' '-2' ) "100"#( '+1' '+3' '-4' '-1' ) "101"#( '+1' '+3' '-3' '-1' ) "102"#( '+1' '+3' '-2' '-4' ) "103"#( '+1' '+3' '-2' '-3' ) "104"#( '+1' '+3' '-1' '-3' ) "105"#( '+1' '+4' '+1' '-4' ) "106"#( '+1' '+4' '+1' '-3' ) "107"#( '+1' '+4' '+1' '-2' ) "108"#( '+1' '+4' '+1' '-1' ) "109"#( '+1' '+4' '+2' '+3' ) "110"#( '+1' '+4' '+2' '-4' ) "111"#( '+1' '+4' '+2' '-3' ) "112"#( '+1' '+4' '+2' '-2' ) "113"#( '+1' '+4' '+2' '-1' ) "114"#( '+1' '+4' '+3' '-4' ) "115"#( '+1' '+4' '+3' '-3' ) "116"#( '+1' '+4' '+3' '-2' ) "117"#( '+1' '+4' '+3' '-1' ) "118"#( '+1' '+4' '-4' '-4' ) "119"#( '+1' '+4' '-4' '-2' ) "120"#( '+1' '+4' '-4' '-1' ) "121"#( '+1' '+4' '-3' '-2' ) "122"#( '+1' '+4' '-2' '-4' ) "123"#( '+1' '+4' '-2' '-3' ) "124"#( '+1' '+4' '-2' '-2' ) "125"#( '+1' '+4' '-1' '-4' ) "126"#( '+1' '-4' '-4' '+1' ) "127"#( '+1' '-4' '-4' '+2' ) "128"#( '+1' '-4' '-4' '+3' ) "129"#( '+1' '-4' '-4' '+4' ) "130"#( '+1' '-4' '-3' '+2' ) "131"#( '+1' '-4' '-3' '+3' ) "132"#( '+1' '-4' '-3' '+4' ) "133"#( '+1' '-4' '-2' '+2' ) "134"#( '+1' '-4' '-2' '+3' ) "135"#( '+1' '-4' '-2' '+4' ) "136"#( '+1' '-4' '-1' '+2' ) "137"#( '+1' '-4' '-1' '+3' ) "138"#( '+1' '-4' '-1' '+4' ) "139"#( '+1' '-3' '+1' '-3' ) "140"#( '+1' '-3' '+1' '-1' ) "141"#( '+1' '-3' '+3' '-1' ) "142"#( '+1' '-3' '-3' '+1' ) "143"#( '+1' '-3' '-3' '+3' ) "144"#( '+1' '-3' '-3' '+4' ) "145"#( '+1' '-3' '-2' '+4' ) "146"#( '+1' '-3' '-1' '+3' ) "147"#( '+1' '-2' '-3' '+4' ) "148"#( '+1' '-2' '-2' '+1' ) "149"#( '+1' '-2' '-2' '+4' ) "150"#( '+1' '-1' '+1' '-1' ) "151"#( '+1' '-1' '+3' '-3' ) "152"#( '+1' '-1' '-3' '+3' ) "153"#( '+1' '-1' '-1' '+1' ) "154") at: (index beBetween: 1 and: 154)! !!ETileBigRoassal class methodsFor: 'instance creation' stamp: 'PeterGraf 2/23/2024 10:44'!newFromFlexiblePatternBackup: aFlexiblePattern tileColorsString: aTileColorsString fileLocator: aFileLocatorerror: aBoolean"Kommt aFlexiblePattern von einem Filenamen, dann sind im File die Farbindizes für das eTile mit rows und columns. Oder mehr, oder weniger.""curFlexiblePattern         1         2         3         4  1234567890123456789012345678901234567890nnnReihenfolge: nnn[T][W][D][F][C][P]nnn				001..154 Index, mandatoryT+1-2+3+4		optional, is info only, default: aus Tabelle	Wwwww 			weavings for t11 t12 t21 t22					optional, default: aus TabelleDrrcc		 	rr = Anzahl Zeilen					cc = Anzahl Spalten					optional, default: rr, cr aus TabelleFrfcf		 	rf = Faktor für die Zeilen					cf = Faktor für die Spalten					optional, default: 01, 01 Cmima		 	mi = minimale Anzahl Farben					ma = maximale Anzahl Farben					optional, is info only, default: aus TabelleP...				options, default: false								bitIndex					't'	withTilePatterns									13			info					'w'	withWeaving 										10					'd'	withDimension 										11							withFactor  										14					'c'	withColorRange 									12			info					'l'	withLines 											1					'i'	withTileFrame										2					'b'	withBigFrame 										3					'a'	automatisch färben								4					'p'  pdf ausgeben, canvas schliessen		6   							withError (intern)								9   "	| fPattern nextPos index rFactor cFactor minRows minColumns optionsString w4 newInstance fourPattern3String errorHappened |		errorHappened := false.		nextPos := 1.	(aFlexiblePattern isString and: [ aFlexiblePattern size >= 3 ]) ifTrue: [		 		fPattern := aFlexiblePattern copyUpToSubstring: '.'. "ohne Extension"		fPattern := fPattern copyUpToSubstring: ' ('. "ohne Version ala chromebook""Transcript show: fPattern; cr."		] ifFalse: [ 		errorHappened := true. 		fPattern := '111Pwdbl' ].	(fPattern size >= 3) ifTrue: [		index := Integer readFrom: (fPattern copyFrom: 1 to: 3) ifFail: [ 			errorHappened := true.			fPattern := '111Pwdbl'.			111 ].		index := index beBetween: 1 and: 154.	] ifFalse: [		errorHappened := true. 		index := 111. 		fPattern := '111Pwdbl' ].	nextPos := 4.	"tile patterns"	( (fPattern size - nextPos >= (9 - 1)) and: [ (fPattern at: nextPos) = $T ] ) ifTrue: [		nextPos := nextPos + 9. "skippen"	].	"weaving"	( (fPattern size - nextPos >= (5 - 1)) and: [ (fPattern at: nextPos) = $W ] ) ifTrue: [		nextPos := nextPos + 1. "$W skippen"		w4 := fPattern copyFrom: nextPos to: nextPos + (4-1).		w4 copy do: [ :letter |			('abcd' includes: letter) ifFalse: [ w4 := nil ]		].		nextPos := nextPos + 4	] ifFalse: [ w4 := nil ].	minRows := (self tileSizes154 at: index) first.	minColumns := (self tileSizes154 at: index) second.	( (fPattern size - nextPos >= (5 - 1)) and: [ (fPattern at: nextPos) = $D ] ) ifTrue: [		nextPos := nextPos + 1. "$D"		minRows := Integer readFrom: (fPattern copyFrom: nextPos to: nextPos + (2-1)) 							ifFail: [ (self tileSizes154 at: index) first ]. 		nextPos := nextPos + 2.		minRows := minRows beBetween: 2 and: 40.		minColumns := Integer readFrom: (fPattern copyFrom: nextPos to: nextPos + (2-1)) 							ifFail: [ (self tileSizes154 at: index) second ]. 		nextPos := nextPos + 2.		minColumns := minColumns beBetween: 2 and: 40.	].	rFactor := 1.	cFactor := 1.	( (fPattern size - nextPos >= (5 - 1)) and: [ (fPattern at: nextPos) = $F ] ) ifTrue: [		nextPos := nextPos + 1. "$F"		rFactor := Integer readFrom: (fPattern copyFrom: nextPos to: nextPos + (2-1)) 							ifFail: [ 1 ]. 		nextPos := nextPos + 2.		rFactor := rFactor beBetween: 1 and: 40.		cFactor := Integer readFrom: (fPattern copyFrom: nextPos to: nextPos + (2-1)) 							ifFail: [ 1 ]. 		nextPos := nextPos + 2.		cFactor := cFactor beBetween: 1 and: 40.	].		"colorRange"	( (fPattern size - nextPos >= (5 - 1)) and: [ (fPattern at: nextPos) = $C ] ) ifTrue: [		nextPos := nextPos + 5. "skippen"	].	"options"	( (fPattern size - nextPos >= 2) and: [ (fPattern at: nextPos) = $P ] ) ifTrue: [		nextPos := nextPos + 1.		optionsString := fPattern copyFrom: nextPos to: fPattern size	] ifFalse: [ optionsString := '' ]."Transcript show: optionsString; cr."	fourPattern3String := (self fourPattern3StringAt: index).	"z.B. #( '+1a' '+1b' '+1c' '+1d' ) mit default weaving"	w4 ifNotNil: [ 		1 to: 4 do: [ :i | (fourPattern3String at: i) at: 3 put: (w4 at: i) ]	].	rFactor := rFactor min: (100 // minRows).	cFactor := cFactor min: (100 // minColumns).	newInstance := self new		fileLocator: aFileLocator;		rows: minRows * rFactor;		columns: minColumns * cFactor.	(optionsString includesSubstring: 't' caseSensitive: true) ifTrue: [ newInstance withTilePatterns: true ].	(optionsString includesSubstring: 'w' caseSensitive: true) ifTrue: [ newInstance withWeaving: true ].	(optionsString includesSubstring: 'd' caseSensitive: true) ifTrue: [ newInstance withDimension: true ].	(optionsString includesSubstring: 'b' caseSensitive: true) ifTrue: [ newInstance withBigFrame: true ].	(optionsString includesSubstring: 'i' caseSensitive: true) ifTrue: [ newInstance withTileFrame: true ].	(optionsString includesSubstring: 'l' caseSensitive: true) ifTrue: [ newInstance withLines: true ].	(optionsString includesSubstring: 'a' caseSensitive: true) ifTrue: [ newInstance withAutoColoringFew: true ].	(optionsString includesSubstring: 'p' caseSensitive: true) ifTrue: [ newInstance withPdf: true ].	errorHappened ifTrue: [ newInstance withError: true ].	"( rFactor ~= 1 or: [ cFactor ~= 1] ) ifTrue: [ newInstance withFactors: true ]."	newInstance withError ifTrue: [		newInstance withBigFrame: true.		newInstance withLines: true.		newInstance withWeaving: true.		newInstance withDimension: true.		newInstance withAutoColoringFew: false.		newInstance withPdf: false.		"newInstance withFactors: false."	] ifFalse: [		aTileColorsString ifNotNil: [ | ind |			ind := 1.			newInstance tileColorIndices2D:  				( Array2D rows: newInstance rows columns: newInstance columns tabulate: 					[ :r :c |						| arr |						arr := Array new: 5. "5 Farbindizes oder nil für die Polynome im tile"						1 to: 5 do: [ :k | | val | 							val := [ (aTileColorsString at: ind) asInteger ] onErrorDo: [ 0 ].							val isZero ifTrue: [ val := nil ].							arr at: k put: val.							ind := ind + 1						].						arr					]				).		]."Transcript show: newInstance basicTileColorIndices2D asString; cr. "		rFactor * cFactor > 1 ifTrue: [			| arr2D |			arr2D := newInstance tileColorIndices2D.			1 to: newInstance rows do: [ :i |				1 to: newInstance columns do: [ :j |												arr2D at: i at: j 					put: ( arr2D at: (i-1) % minRows + 1 at: (j-1) % minColumns + 1  ) ]]].	].	newInstance 		theIndex: index;		fourPattern3: fourPattern3String.	newInstance	allTiles: ( Array2D rows: newInstance rows columns: newInstance columns ).	newInstance spreadPattern.	^ newInstance start! !!ETileBigRoassal class methodsFor: 'instance creation' stamp: 'PeterGraf 3/10/2024 13:45'!newFromFlexiblePattern: aFlexiblePattern tileColorsString: aTileColorsString fileLocator: aFileLocatorerror: aBooleanError"Kommt aFlexiblePattern von einem Filenamen, dann sind im File die Farbindizes für das eTile mit rows und columns. Oder mehr, oder weniger.""curFlexiblePattern 23.02.2024         1         2         3         4  1234567890123456789012345678901234567890nnnFilename = 'nnn'['Ttttt']['Wwwww']['Drrcc']['Frfcf']['P...']'.txt'nnn				'001'..'154' Index, mandatoryTtttt			t = '+1'|'+2'|'+3'|'+4'|'-1'|'-2'|'-3'|'-4'					optional, is info only, default: from tableWwwww 			w = 'a'|'b'|'c'|'d'					weavings for t11 t12 t21 t22					optional, default: from tableDrrcc		 	rr = '01'..'99', cc = '01'..'99'					rr = number of rows					cc = number of columns					optional, default: rr, cc from tableFrfcf		 	rf = '01'..'99', cf = '01'..'99'					rf = rows factor					cf = columns factor					optional, default: rf = '01', cf = '01'P...				options, up to ' ' or '.',					default: false											bitIndex					't'	withTilePatterns									13			info					'w'	withWeaving 										10					'd'	withDimension 										11					'b'	withBigFrame 										3					'i'	withTileFrame										2					'l'	withLines 											1					'f'	color with few colors							4					'm'	color with many colors						5					'p'  export PDF, close window					6   							withError (internal)							9   "	| fPattern nextPos index rFactor cFactor minRows minColumns optionsString w4 newInstance fourPattern3String errorHappened |	fPattern := aFlexiblePattern.	errorHappened := aBooleanError.	errorHappened ifTrue: [ 		index := 111. 		fPattern := '111Pwdbl' ].	"Transcript show: fPattern; space; show: errorHappened asString; cr."		nextPos := 1.	(fPattern isString and: [ fPattern size >= 3 ]) ifTrue: [		 		fPattern := fPattern copyUpToSubstring: '.'. "without extension"		fPattern := fPattern copyUpToSubstring: ' ('. "without version ala chromebook"	] ifFalse: [ 		errorHappened := true. 		fPattern := '111Pwdbl' ].	(fPattern size >= 3) ifTrue: [		index := Integer readFrom: (fPattern copyFrom: 1 to: 3) ifFail: [ 			errorHappened := true.			fPattern := '111Pwdbl'.			111 ].		index := index beBetween: 1 and: 154.	] ifFalse: [		errorHappened := true. 		index := 111. 		fPattern := '111Pwdbl' ].	nextPos := 4.	"tile patterns"	( (fPattern size - nextPos >= (9 - 1)) and: [ (fPattern at: nextPos) = $T ] ) ifTrue: [		nextPos := nextPos + 9. "skip"	].	"weaving"	( (fPattern size - nextPos >= (5 - 1)) and: [ (fPattern at: nextPos) = $W ] ) ifTrue: [		nextPos := nextPos + 1. "$W"		w4 := fPattern copyFrom: nextPos to: nextPos + (4-1).		w4 copy do: [ :letter |			('abcd' includes: letter) ifFalse: [ w4 := nil ]		].		nextPos := nextPos + 4	] ifFalse: [ w4 := nil ].	minRows := (self tileSizes154 at: index) first.	minColumns := (self tileSizes154 at: index) second.	( (fPattern size - nextPos >= (5 - 1)) and: [ (fPattern at: nextPos) = $D ] ) ifTrue: [		nextPos := nextPos + 1. "$D"		minRows := Integer readFrom: (fPattern copyFrom: nextPos to: nextPos + (2-1)) 							ifFail: [ (self tileSizes154 at: index) first ]. 		nextPos := nextPos + 2.		minRows := minRows beBetween: 2 and: 49.		minColumns := Integer readFrom: (fPattern copyFrom: nextPos to: nextPos + (2-1)) 							ifFail: [ (self tileSizes154 at: index) second ]. 		nextPos := nextPos + 2.		minColumns := minColumns beBetween: 2 and: 49.	].	rFactor := 1.	cFactor := 1.	( (fPattern size - nextPos >= (5 - 1)) and: [ (fPattern at: nextPos) = $F ] ) ifTrue: [		nextPos := nextPos + 1. "$F"		rFactor := Integer readFrom: (fPattern copyFrom: nextPos to: nextPos + (2-1)) 							ifFail: [ 1 ]. 		nextPos := nextPos + 2.		rFactor := rFactor beBetween: 1 and: 99.		cFactor := Integer readFrom: (fPattern copyFrom: nextPos to: nextPos + (2-1)) 							ifFail: [ 1 ]. 		nextPos := nextPos + 2.		cFactor := cFactor beBetween: 1 and: 99.	].		"colorRange"	"( (fPattern size - nextPos >= (5 - 1)) and: [ (fPattern at: nextPos) = $C ] ) ifTrue: [		nextPos := nextPos + 5.	]."	"options"	( (fPattern size - nextPos >= 2) and: [ (fPattern at: nextPos) = $P ] ) ifTrue: [		nextPos := nextPos + 1.		optionsString := fPattern copyFrom: nextPos to: fPattern size	] ifFalse: [ optionsString := '' ].	fourPattern3String := (self fourPattern3StringAt: index).	"z.B. #( '+1a' '+1b' '+1c' '+1d' ) mit default weaving"	w4 ifNotNil: [ 		1 to: 4 do: [ :i | (fourPattern3String at: i) at: 3 put: (w4 at: i) ]	].	rFactor := rFactor min: (100 // minRows).	cFactor := cFactor min: (100 // minColumns).	newInstance := self new		fileLocator: aFileLocator;		rows: minRows * rFactor; "1..99"		columns: minColumns * cFactor. "1..99"	(optionsString includesSubstring: 't' caseSensitive: true) ifTrue: [ newInstance withTilePatterns: true ].	(optionsString includesSubstring: 'w' caseSensitive: true) ifTrue: [ newInstance withWeaving: true ].	(optionsString includesSubstring: 'd' caseSensitive: true) ifTrue: [ newInstance withDimension: true ].	(optionsString includesSubstring: 'b' caseSensitive: true) ifTrue: [ newInstance withBigFrame: true ].	(optionsString includesSubstring: 'i' caseSensitive: true) ifTrue: [ newInstance withTileFrame: true ].	(optionsString includesSubstring: 'l' caseSensitive: true) ifTrue: [ newInstance withLines: true ].	(optionsString includesSubstring: 'f' caseSensitive: true) ifTrue: [ 		newInstance withAutoColoringFew: true.		newInstance withAutoColoringMany: false ].	(optionsString includesSubstring: 'm' caseSensitive: true) ifTrue: [ 		newInstance withAutoColoringMany: true.		newInstance withAutoColoringFew: false ].	(optionsString includesSubstring: 'p' caseSensitive: true) ifTrue: [ newInstance withPdf: true ].	errorHappened ifTrue: [ newInstance withError: true ].	newInstance withError ifTrue: [		newInstance withBigFrame: true.		newInstance withLines: true.		newInstance withWeaving: true.		newInstance withDimension: true.		newInstance withAutoColoringFew: false.		newInstance withPdf: false.	] ifFalse: [		aTileColorsString ifNotNil: [ 			| ind arr2D |			ind := 1.			"All tiles"			arr2D := Array2D rows: newInstance rows columns: newInstance columns.			"Fill the top left rectangle minRow, minColumns with the colorindices from the file"			1 to: minRows do: [ :i |				1 to: minColumns do: [ :j |					| arr |					arr := Array new: 5. "5 colorindices or nil for the polygons in the tile"					1 to: 5 do: [ :k | | val | 						val := [ (aTileColorsString at: ind) asInteger ] onErrorDo: [ 0 ].						val isZero ifTrue: [ val := nil ].						arr at: k put: val.						ind := ind + 1 ].					arr2D at: i at: j put: arr ]].						newInstance tileColorIndices2D: arr2D.  						rFactor * cFactor > 1 ifTrue: [				"Copy the colorindices to the other rectangles of size minRows, minColumns"				1 to: newInstance rows do: [ :i |					1 to: newInstance columns do: [ :j |						arr2D at: i at: j 						put: ( arr2D at: (i-1) % minRows + 1 at: (j-1) % minColumns + 1  ) ]].								]		] "ifNotNil"	]. "ifFalse"	newInstance 		theIndex: index;		fourPattern3: fourPattern3String.	newInstance	allTiles: ( Array2D rows: newInstance rows columns: newInstance columns ).	newInstance spreadPattern.	^ newInstance start! !!ETileBigRoassal class methodsFor: 'instance creation' stamp: 'PeterGraf 3/2/2024 12:06'!newFromFileName: aBasename fileLocator: aFileLocator""	| fileRef tileColorsString |	"fileLocator := (FileLocator home / 'eTiles') ensureCreateDirectory."	aFileLocator ensureCreateDirectory.	fileRef := aFileLocator / aBasename."Transcript show: aBasename; cr."	fileRef exists ifFalse: [ 		^ self 				newFromFlexiblePattern: aBasename				tileColorsString: nil  				fileLocator: aFileLocator				error: true	].  		( (aBasename splitOnFirst: $.) second ~= 'txt' ) ifTrue: [ 		^ self 				newFromFlexiblePattern: aBasename				tileColorsString: nil  				fileLocator: aFileLocator				error: true	].  		fileRef size >= 10000 ifTrue: [ 		^ self 				newFromFlexiblePattern: aBasename				tileColorsString: nil  				fileLocator: aFileLocator				error: false ].  		fileRef readStreamDo: [ :stream | | coll |		coll := [ ([:c| c isSeparator] split: stream contents asString) ] onErrorDo: [ nil ]. 		coll ifNotNil: [			tileColorsString := ( coll select: [ :str | str size ~= 0 ] ) asArray ]].	^ self 			newFromFlexiblePattern: ( aBasename splitOnFirst: $. ) first			tileColorsString: tileColorsString			fileLocator: aFileLocator			error: false! !RSQualitativeColorPalette subclass: #ETileColorPalette	instanceVariableNames: ''	classVariableNames: ''	package: 'Pedro1'!!ETileColorPalette commentStamp: 'PeterGraf 2/13/2024 14:12' prior: 0!paired12, greys8, set19!!ETileColorPalette methodsFor: 'accessing' stamp: 'PeterGraf 3/6/2024 14:42'!mixed35 	^ self fromTriplet: #( #(166 206 227) #(31 120 180) #(178 223 138) #(51 160 44) #(251 154 153) #(227 26 28) #(253 191 111) #(255 127 0) #(202 178 214) #(106 61 154) #(255 255 153) #(177 89 40) "paired12"#(141 211 199) #(255 255 179) #(190 186 218) #(251 128 114) #(128 177 211) #(253 180 98) #(179 222 105) #(252 205 229) "set38"#(255 255 255) #(240 240 240) #(217 217 217) #(189 189 189) #(150 150 150) #(115 115 115) #(82 82 82) #(37 37 37) "greys8"#(215 25 28) #(253 174 97) #(255 255 191) #(171 221 164) #(43 131 186) "spectral5"#(152 78 163) #(247 129 191) "from set19")"paired12	^ self fromTriplet: #(#(166 206 227) #(31 120 180) #(178 223 138) #(51 160 44) #(251 154 153) #(227 26 28) #(253 191 111) #(255 127 0) #(202 178 214) #(106 61 154) #(255 255 153) #(177 89 40))greys8	^ self fromTriplet: #(#(255 255 255) #(240 240 240) #(217 217 217) #(189 189 189) #(150 150 150) #(115 115 115) #(82 82 82) #(37 37 37))set19	^ self fromTriplet: #(#(228 26 28) #(55 126 184) #(77 175 74)   #(152 78 163)   #(255 127 0) #(255 255 51) #(166 86 40)    #(247 129 191)   #(153 153 153))spectral5	^ self fromTriplet: #(#(215 25 28) #(253 174 97) #(255 255 191) #(171 221 164) #(43 131 186))set38	^ self fromTriplet: #(#(141 211 199) #(255 255 179) #(190 186 218) #(251 128 114) #(128 177 211) #(253 180 98) #(179 222 105) #(252 205 229))"! !FileListGrid subclass: #ETileFileListGrid	instanceVariableNames: ''	classVariableNames: ''	package: 'Pedro1'!!ETileFileListGrid commentStamp: 'PeterGraf 2/13/2024 10:57' prior: 0!Spaltenbreiten in der filelist einstellen!!ETileFileListGrid methodsFor: 'user interface' stamp: 'PeterGraf 2/14/2024 14:26'!treeMorph	treeMorph ifNil: [		treeMorph := (self treeMorphClass on: self)			columns: {				MorphTreeColumn new					rowMorphGetSelector: #fileName;					startWidth: 400;					headerButtonLabel: 'File name' translated						font: nil						target: self parent						actionSelector: #setSortSelector: arguments: { #sortBlockBasename }.				MorphTreeColumn new					rowMorphGetSelector: #fileSize;					startWidth: 70;					headerButtonLabel: 'Size' translated font: nil						target: self parent						actionSelector: #setSortSelector: arguments: { #sortBlockFilesize }.				MorphTreeColumn new					rowMorphGetSelector: #modificationDate;					headerButtonLabel: 'Last mod.' translated font: nil						target: self parent						actionSelector: #setSortSelector: arguments: { #sortBlockTimestamp }."				MorphTreeColumn new					rowMorphGetSelector: #filePermissions;					headerButtonLabel: 'Permissions' translated font: nil						target: self parent						actionSelector: #setSortSelector: arguments: { #sortBlockPermissions }"					}.		treeMorph			hResizing: #spaceFill;			vResizing: #spaceFill;			columnInset: 3;			getMenuSelector: #fileListMenu:;			makeLastColumnUnbounded.	].	^ treeMorph buildContents! !Object subclass: #ETilePolygonRoassal	instanceVariableNames: 'eTile polygonIndex pointsIndices pointsRoassal outerLinesIndices outerLinesRoassal innerLinesIndices innerLinesRoassal colorIndex rsPolygon rsLinesInner rsLinesOuter strandIndex'	classVariableNames: ''	package: 'Pedro1'!!ETilePolygonRoassal commentStamp: 'PeterGraf 1/25/2024 10:51' prior: 0!Ein ETilePolygon besteht aus der Liste polygonIndices,innerLineIndices und outerLineIndices.Je zwei aufeinanderfolgende Einträge in polygonIndicesdefinieren eine Linie.Der letzte Punkt in der Liste ist mit dem ersten Punktin der Liste verbunden.Die Einträge in innerLineIndices und outerLineIndicesdefinieren eine Linie.Die Linien in innerLineIndices sind die Linien des Polygons,die im Inneren des Qaudrats verlaufen.Die Linien in outerLineIndices sind die Linien des Polygons,die am Rand des Qaudrats verlaufen.Der Aufbau von innerLineIndices und outerLineIndices erfolgt dynamisch. pointsRoassal, innerLinesRoassal und outerLinesRoassal hält die 2 bis 3 Linien des Polygons am Rand des Quadrats.Die Punkte sind so, wie sie an Roassal gegeben wurden.Ein Polygon gehört zu einem strand.Ein strand enthält alle Polygone, die über die outerlinesmiteinander verbunden sind.!!ETilePolygonRoassal methodsFor: 'backtracking' stamp: 'PeterGraf 2/29/2024 08:41'!setStrandRecursively: newStrandIndex"strand im Polygon setzen und weitergeben.Nebenbei die Längen der strand (indirekt) bestimmen.lineDict ist bereits gefüllt."	strandIndex ifNotNil: [ ^ self ]. 	strandIndex := newStrandIndex.	"Hier die strands anhängen.	Die Länge der strands wird später gezählt."	eTile bigETile strandsRegistered add: strandIndex.		self lineDict valuesDo: [ :collOfPolygons |		(collOfPolygons includes: self ) ifTrue: [					"Alle diese Polygone liegen im gleichen strand."			collOfPolygons do: [ :polygon |				polygon setStrandRecursively: newStrandIndex 	]]]						! !!ETilePolygonRoassal methodsFor: 'setting' stamp: 'PeterGraf 2/15/2024 12:09'!strandIndex: newStrand	strandIndex := newStrand! !!ETilePolygonRoassal methodsFor: 'testing' stamp: 'PeterGraf 2/29/2024 08:41'!strandIsDiamondWerBrauchtDas" Eigenschaften- Besteht nur aus den Polygonen 2 und 3.- Hat die Länge 4. - Kommt in strandCrossings nicht vor."	^	eTile bigETile strandCrossingsSet detect: [ :e | e first = strandIndex ]			ifFound: [ ^ false ]			ifNone:  [ ^ true ]! !!ETilePolygonRoassal methodsFor: 'update' stamp: 'PeterGraf 2/29/2024 08:39'!updateRSPolygonColorIndex: newColorIndex"Polygon und rsPolygon färben.Ohne Prüfung der kreuzenden strands"	| color lineColor |	colorIndex := newColorIndex.	color := self color.	rsPolygon color: color.	rsLinesOuter do: [ :rsLine | rsLine color: color ].	eTile withLines ifFalse: [ ^ self ].	lineColor := eTile lineColor.	rsLinesInner do: [ :rsLine | rsLine color: lineColor ]! !!ETilePolygonRoassal methodsFor: 'accessing' stamp: 'PeterGraf 1/26/2024 13:18'!eTile	^ eTile! !!ETilePolygonRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/29/2024 08:41'!lineDict 	^ eTile bigETile lineDict! !!ETilePolygonRoassal methodsFor: 'accessing' stamp: 'PeterGraf 1/19/2024 16:41'!outerLinesRoassal	^ outerLinesRoassal! !!ETilePolygonRoassal methodsFor: 'accessing' stamp: 'PeterGraf 1/19/2024 16:18'!pointsRoassal	^ pointsRoassal! !!ETilePolygonRoassal methodsFor: 'accessing' stamp: 'PeterGraf 1/24/2024 22:46'!rsPolygon	^ rsPolygon! !!ETilePolygonRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/3/2024 00:39'!rsLinesInnerAdd: aRsLine	rsLinesInner ifNil: [ rsLinesInner := OrderedCollection new: 2 ].	rsLinesInner add: aRsLine! !!ETilePolygonRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/3/2024 00:26'!rsLinesInner	^ rsLinesInner! !!ETilePolygonRoassal methodsFor: 'accessing' stamp: 'PeterGraf 1/19/2024 16:18'!pointsRoassal: anObject	pointsRoassal := anObject! !!ETilePolygonRoassal methodsFor: 'accessing' stamp: 'PeterGraf 1/18/2024 14:12'!colorIndex	^ colorIndex! !!ETilePolygonRoassal methodsFor: 'accessing' stamp: 'PeterGraf 1/19/2024 15:48'!pointsIndices: anArray	pointsIndices := anArray ! !!ETilePolygonRoassal methodsFor: 'accessing' stamp: 'PeterGraf 1/18/2024 14:13'!colorIndex: anObject	colorIndex := anObject! !!ETilePolygonRoassal methodsFor: 'accessing' stamp: 'PeterGraf 1/19/2024 16:45'!outerLinesIndices	^ outerLinesIndices! !!ETilePolygonRoassal methodsFor: 'accessing' stamp: 'PeterGraf 1/19/2024 15:47'!pointsIndices	^ pointsIndices ! !!ETilePolygonRoassal methodsFor: 'accessing' stamp: 'PeterGraf 1/26/2024 18:29'!polygonIndex: anObject	polygonIndex := anObject! !!ETilePolygonRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/29/2024 07:32'!rsLinesOuterAdd: aRsLine	rsLinesOuter ifNil: [ rsLinesOuter := OrderedCollection new: 3 ].	rsLinesOuter add: aRsLine! !!ETilePolygonRoassal methodsFor: 'accessing' stamp: 'PeterGraf 1/19/2024 16:42'!innerLinesIndices: anObject	innerLinesIndices := anObject! !!ETilePolygonRoassal methodsFor: 'accessing' stamp: 'PeterGraf 1/19/2024 16:45'!outerLinesIndices: anObject	outerLinesIndices := anObject! !!ETilePolygonRoassal methodsFor: 'accessing' stamp: 'PeterGraf 1/19/2024 16:42'!innerLinesRoassal: anObject	innerLinesRoassal := anObject! !!ETilePolygonRoassal methodsFor: 'accessing' stamp: 'PeterGraf 1/24/2024 22:46'!rsPolygon: anObject	rsPolygon := anObject! !!ETilePolygonRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/29/2024 08:41'!color	^ eTile bigETile colorForColorIndex: colorIndex! !!ETilePolygonRoassal methodsFor: 'accessing' stamp: 'PeterGraf 1/26/2024 18:29'!polygonIndex	^ polygonIndex! !!ETilePolygonRoassal methodsFor: 'accessing' stamp: 'PeterGraf 1/26/2024 13:18'!eTile: anObject	eTile := anObject! !!ETilePolygonRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/15/2024 12:09'!strandIndex	^ strandIndex! !!ETilePolygonRoassal methodsFor: 'accessing' stamp: 'PeterGraf 1/19/2024 16:41'!outerLinesRoassal: anObject	outerLinesRoassal := anObject! !!ETilePolygonRoassal methodsFor: 'accessing' stamp: 'PeterGraf 1/19/2024 16:42'!innerLinesRoassal	^ innerLinesRoassal! !!ETilePolygonRoassal methodsFor: 'accessing' stamp: 'PeterGraf 1/19/2024 16:41'!innerLinesIndices	^ innerLinesIndices! !!ETilePolygonRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/29/2024 07:32'!rsLinesOuter	^ rsLinesOuter! !Object subclass: #ETileRoassal	instanceVariableNames: 'row column weaving polygons centerPoint squarePointsRoassal pattern2 bigETile'	classVariableNames: 'Todo'	package: 'Pedro1'!!ETileRoassal commentStamp: 'PeterGraf 2/10/2024 17:33' prior: 0!Ein ETileRoassal wird aus einem ETile erzeugt.centerPoint ist der Ursprung (0@0) des Tiles im canvas von Roassal.Die Polygone 1, 4 und 5 überlappen sich.Es gibt 4 verschiedene Webmuster im #ETile: a, b, c und d.ich	Stan Wagona		leer, defaultb		ac		rrd		rlDie verschiedenen Überlappungen der drei Streifen (Polygone) werden durch verschiedene Reihenfolgen beim Malen erzeugt, siehe #paintPolygons.Die Polygone im Roassal immer ohne Ränder malen.Wenn withLines, dann zusätzlich mit inneren Linien malen.lineDict und outerRoassalLinesEs gibt 2 bis 3 Linien je Polygon, und 1 bis 2 Polygone je Linie.!!ETileRoassal methodsFor: 'private' stamp: 'PeterGraf 2/13/2024 11:38'!buildPolygonIndex: polygonIndex"Daten aufbauen: pointsRoassal innerLinesRoassal outerLinesRoassal lineDict"	| polygon  flatCollRoassal |		polygon := self polygons at: polygonIndex.	polygon polygonIndex: polygonIndex.	polygon 		pointsRoassal: ( polygon pointsIndices collect: [ :i | squarePointsRoassal at: i ] ).	"innerLinesRoassal" 	flatCollRoassal := polygon innerLinesIndices flattened. "total flach"	polygon innerLinesRoassal: ( flatCollRoassal pairsCollect: 		[ :e1 :e2 | { squarePointsRoassal at: e1 . squarePointsRoassal at: e2 } sorted ] ) asArray.	"outerLinesRoassal" 	flatCollRoassal := polygon outerLinesIndices flattened. 	polygon outerLinesRoassal: ( flatCollRoassal pairsCollect: 		[ :e1 :e2 | { squarePointsRoassal at: e1 . squarePointsRoassal at: e2 } sorted ] ) asArray.  		"Aeussere Linien des Polygons als Roassal-Linien in lineDict eintragen.	Ebenso die Polygone zyklisch verbinden.	Es gibt 1 bis 2 Polygone je aeusserer Linie."	polygon outerLinesRoassal do: [ :lineRoassal | 		self lineDictAt: lineRoassal  addOuterLinesPolygon: polygon ]! !!ETileRoassal methodsFor: 'private' stamp: 'PeterGraf 2/29/2024 08:40'!lineDictAt: lineRoassal addOuterLinesPolygon: anETilePolygon	"	Aeussere Linie eines Polygons ins lineDict eintragen.	Es gibt 2 Polygone je aeusserer Linie.	Es soll '{1@2 . 3@4} sorted = {3@4 . 1@2} sorted' gelten."	| minX minY maxX maxY lineRoassalSorted |	lineRoassalSorted := lineRoassal sorted.			maxX := 50 * bigETile columns.	minX := maxX negated. 	maxY := 50 * bigETile rows.	minY := maxY negated. 	"2 Polygone je Linie."	self basicLineDictAt: lineRoassalSorted addPolygon: anETilePolygon.	"Polygone zyklisch verbinden"	( lineRoassal first x = minX and: [ lineRoassal second x = minX ] ) ifTrue: [  			"2 Polygone je Linie."		self basicLineDictAt:			{ lineRoassal first x negated  @ lineRoassal first y . 				lineRoassal second x negated @ lineRoassal second y } sorted 			addPolygon: anETilePolygon.			] ifFalse: [ 			( lineRoassal first y = minY and: [ lineRoassal second y = minY ] ) ifTrue: [  			"2 Polygone je Linie."			self basicLineDictAt:					{ lineRoassal first x @ lineRoassal first y negated . 						lineRoassal second x @ lineRoassal second y negated } sorted 				addPolygon: anETilePolygon. ]]! !!ETileRoassal methodsFor: 'private' stamp: 'PeterGraf 1/19/2024 20:34'!flipIndicesHorizontally"Die Indizes in den Polygonen in der Mitte horizontal spiegeln."	| flipArray |	flipArray := #( 2 1 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3 ).		self polygons do: [ :polygon |					1 to: polygon pointsIndices size do: [ :i | | val arr |			arr := polygon pointsIndices.			val := flipArray at: ( arr at: i).			arr at: i put: val.		].		polygon innerLinesIndices do: [ :lineIndices |			lineIndices at: 1 put: ( flipArray at: (lineIndices at: 1) ).			lineIndices at: 2 put: ( flipArray at: (lineIndices at: 2) ).		].		polygon outerLinesIndices do: [ :lineIndices |			lineIndices at: 1 put: ( flipArray at: (lineIndices at: 1) ).			lineIndices at: 2 put: ( flipArray at: (lineIndices at: 2) ).		].	]! !!ETileRoassal methodsFor: 'private' stamp: 'PeterGraf 1/19/2024 20:35'!rotateIndicesLeft: aCertainInteger	"	ETile nach links drehen   	 5: 90°, 10: 180°, 15: 270°	"	( #( 5 10 15 ) includes: aCertainInteger ) ifTrue: [		self polygons do: [ :polygon |						1 to: polygon pointsIndices size do: [ :i | | arr |				arr:= polygon pointsIndices.				arr at: i put: ( (arr at: i) + aCertainInteger - 1 ) % 20 + 1.			].				polygon innerLinesIndices do: [ :lineIndices |				lineIndices at: 1 put: ( (lineIndices at: 1) + aCertainInteger - 1 ) % 20 + 1.				lineIndices at: 2 put: ( (lineIndices at: 2) + aCertainInteger - 1 ) % 20 + 1.			].			polygon outerLinesIndices do: [ :lineIndices |				lineIndices at: 1 put: ( (lineIndices at: 1) + aCertainInteger - 1 ) % 20 + 1.				lineIndices at: 2 put: ( (lineIndices at: 2) + aCertainInteger - 1 ) % 20 + 1.			].		]	]! !!ETileRoassal methodsFor: 'private' stamp: 'PeterGraf 2/13/2024 09:50'!basicLineDictAt: aLineRoassalSorted addPolygon: anETilePolygon	| sortedRoassalLine |	sortedRoassalLine := aLineRoassalSorted sorted.		self lineDict at: sortedRoassalLine		ifAbsentPut: [ 			"Jeweils 2 Polygone je Linie."			OrderedCollection new: 2		].	( self lineDict at: sortedRoassalLine ) add: anETilePolygon! !!ETileRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/29/2024 08:40'!lineColor 	^ bigETile lineColor ! !!ETileRoassal methodsFor: 'accessing' stamp: 'PeterGraf 1/26/2024 11:50'!row: anObject	row := anObject! !!ETileRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/29/2024 08:41'!bigETile	^ bigETile! !!ETileRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/29/2024 08:40'!lineDict 	^ bigETile lineDict! !!ETileRoassal methodsFor: 'accessing' stamp: 'PeterGraf 1/19/2024 16:08'!squarePointsRoassal	^ squarePointsRoassal! !!ETileRoassal methodsFor: 'accessing' stamp: 'PeterGraf 1/26/2024 11:50'!column	^ column! !!ETileRoassal methodsFor: 'accessing' stamp: 'PeterGraf 1/19/2024 16:14'!squarePointsRoassal: aListOfPoints	squarePointsRoassal := aListOfPoints! !!ETileRoassal methodsFor: 'accessing' stamp: 'PeterGraf 1/26/2024 11:50'!column: anObject	column := anObject! !!ETileRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/29/2024 08:41'!bigETile: anObject	bigETile := anObject! !!ETileRoassal methodsFor: 'accessing' stamp: 'PeterGraf 1/19/2024 20:30'!polygons	^ polygons! !!ETileRoassal methodsFor: 'accessing' stamp: 'PeterGraf 1/26/2024 11:50'!row	^ row! !!ETileRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/29/2024 08:40'!backgroundColor	^ bigETile backgroundColor  ! !!ETileRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/29/2024 08:40'!withLines	^ bigETile withLines! !!ETileRoassal methodsFor: 'accessing' stamp: 'PeterGraf 1/19/2024 20:30'!polygons: anObject	polygons := anObject! !!ETileRoassal methodsFor: 'accessing' stamp: 'PeterGraf 2/29/2024 08:40'!withTileFrame 	^ bigETile withTileFrame! !!ETileRoassal methodsFor: 'accessing' stamp: 'PeterGraf 1/26/2024 12:20'!weaving: anObject	weaving := anObject! !!ETileRoassal methodsFor: 'accessing' stamp: 'PeterGraf 1/6/2024 11:18'!centerPoint	^ centerPoint ! !!ETileRoassal methodsFor: 'accessing' stamp: 'PeterGraf 1/26/2024 12:20'!weaving	^ weaving! !!ETileRoassal methodsFor: 'paint' stamp: 'PeterGraf 2/15/2024 22:47'!paintTileFrameOn: aCanvas 		aCanvas add: ( 		RSPolyline new controlPoints: squarePointsRoassal; 		color: Color black; 		capRound ).	! !!ETileRoassal methodsFor: 'paint' stamp: 'PeterGraf 2/13/2024 11:56'!paintOnCanvas: aCanvas" Alle 5 Polygone eines ETiles malen.Dabei das Webmuster beachten.Das Webmuster ist die Reihenfolge in der die sich überlappenden Polygone eines ETiles gemalt werden.Die Reihenfolge der Polygone ist wie bei Stan Wagon."	"Diese überlappen nicht."	self paintPolygonIndex: 2 on: aCanvas.	self paintPolygonIndex: 3 on: aCanvas.		" 4 mögliche Webmuster"	(weaving = $a) ifTrue: [ "1 unter 4, 4 unter 5" "Stan Wagon: empty"		self paintPolygonIndex: 1 on: aCanvas. 		self paintPolygonIndex: 4 on: aCanvas. 		self paintPolygonIndex: 5 on: aCanvas.	 ] ifFalse: [ 	(weaving = $b) ifTrue: [ "5 unter 4, 4 unter 1" "Stan Wagon: a"		self paintPolygonIndex: 5 on: aCanvas. 		self paintPolygonIndex: 4 on: aCanvas. 		self paintPolygonIndex: 1 on: aCanvas.	 ] ifFalse: [ 	(weaving = $c) ifTrue: [ "4 über 1 und 5"  "Stan Wagon: rr"		self paintPolygonIndex: 1 on: aCanvas. 		self paintPolygonIndex: 5 on: aCanvas. 		self paintPolygonIndex: 4 on: aCanvas.	 ] ifFalse: [ 	(weaving = $d) ifTrue: [ "4 unter 1 und 5"  "Stan Wagon: rl"		self paintPolygonIndex: 4 on: aCanvas. 		self paintPolygonIndex: 1 on: aCanvas. 		self paintPolygonIndex: 5 on: aCanvas.	 ]	] ] ].	self withTileFrame ifTrue: [	 self paintTileFrameOn: aCanvas ]	! !!ETileRoassal methodsFor: 'building' stamp: 'PeterGraf 2/1/2024 13:46'!buildPolygons" Alle 5 Polygone eines ETiles aufbauen.Die Reihenfolge der Polygone ist wie bei Stan Wagon."	1 to: self polygons size do: [ :i | self buildPolygonIndex: i ]."self lineDict inspect."! !!ETileRoassal methodsFor: 'setter' stamp: 'PeterGraf 2/13/2024 09:40'!centerPoint: aPoint"Alle Punkte in 'squarePointsRoassal' an den neuen centerPoint anpassen.Darauf beziehen sich die Indices aller Polygone."	centerPoint := aPoint. "nicht self centerPoint: verwenden"  self squarePointsRoassal: ( self class basicSquarePointsRoassal collect: [ :each | each + centerPoint ] )."	Transcript show: centerPoint; cr.Transcript show: self basicPointsRoassal; cr.Transcript show: pointsRoassal; cr; cr."	! !!ETileRoassal methodsFor: 'initialization' stamp: 'PeterGraf 2/13/2024 09:42'!initialize	super initialize.	"squarePointsRoassal := self class basicSquarePointsRoassal.	centerPoint := 0@0."	! !!ETileRoassal methodsFor: 'private-paint' stamp: 'PeterGraf 2/29/2024 19:34'!paintPolygonIndex: polygonIndex on: aCanvas"Das Polygon als Fläche ohne Ränder malen.Dabei das Webmuster beachten.Das Webmuster ist die Reihenfolge in der die sich überlappenden Polygone eines ETiles gemalt werden.Soll das Webmuster erhalten bleiben, dann muessen eventuell bis zu 3Polygone in der richtigen Reihenfolge gemalt werden, siehe paintOn: ." 	| polygon |		polygon := self polygons at: polygonIndex.		polygon rsPolygon: ( 		RSPolygon new 			points: polygon pointsRoassal; 			color: polygon color ).				aCanvas add: polygon rsPolygon.				"Wegen den feinen Strichen zwischen den Polygone, die nicht gemalt werden."	polygon outerLinesRoassal do: [ :lineRoassal | | rsLine |					rsLine := 			RSLine new 				from: lineRoassal first; 				to: lineRoassal second; 				color: polygon color.							rsLine			width: 0.18;			capRound.		polygon rsLinesOuterAdd: rsLine.		aCanvas add: rsLine ].	self withLines ifTrue: [		"Innere Linien des Polygons malen"					polygon innerLinesRoassal do: [ :lineRoassal | | rsLine |						rsLine := 				RSLine new 					from: lineRoassal first; 					to: lineRoassal second; 					color: self lineColor.								rsLine				width: 0.6;				capRound.			polygon rsLinesInnerAdd: rsLine.			aCanvas add: rsLine ]]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ETileRoassal class	instanceVariableNames: ''!!ETileRoassal class methodsFor: 'instance creation' stamp: 'PeterGraf 2/10/2024 15:03'!newFromPattern3: aPattern3"z.B. '+1a'"" Rotiert und flippt die Indizes. weaving:"	| eTileRoassal at2 |		eTileRoassal := self new.	eTileRoassal weaving: (aPattern3 at: 3).	at2 := aPattern3 at: 2.		eTileRoassal polygons: self basicPolygonsIndices.	eTileRoassal polygons do: [ :pol | pol eTile: eTileRoassal ].		(at2 = $1) ifFalse: [		(at2 = $2) ifTrue: [ eTileRoassal rotateIndicesLeft: 5 "90°" ] ifFalse: [			(at2 = $3) ifTrue: [ eTileRoassal rotateIndicesLeft: 10 "180°" ] ifFalse: [				(at2 = $4) ifTrue: [ eTileRoassal rotateIndicesLeft: 15 "270°" ]			]		]	].	((aPattern3 at: 1) = $-) ifTrue: [ eTileRoassal flipIndicesHorizontally ].		^ eTileRoassal! !!ETileRoassal class methodsFor: 'constants' stamp: 'PeterGraf 1/19/2024 16:09'!basicSquarePointsRoassal"Punkindizes  beziehen sich auf die Punkte in pointsRoassal.Das sind Punkte, die sich auf den Rändern eines 100x100 Quadrats befinden.Und zwar so angeordnet, wie unten.Die konkrete Wahl 100x100 muss nicht eingehalten werden."	"20 Randpunkte"	"Punkte für Roassal am 100x100 Quadrat"^ {	"01"  50 @  10.	"02"  50 @ -10.	"03"  50 @ -30.	"04"  50 @ -50.	"05"  30 @ -50.	"06"  10 @ -50.	"07" -10 @ -50.	"08" -30 @ -50.	"09" -50 @ -50.	"10" -50 @ -30.	"11" -50 @ -10.	"12" -50 @  10.	"13" -50 @  30.	"14" -50 @  50.	"15" -30 @  50.	"16" -10 @  50.	"17"  10 @  50.	"18"  30 @  50.	"19"  50 @  50.	"20"  50 @  30.	}! !!ETileRoassal class methodsFor: 'constants' stamp: 'PeterGraf 2/10/2024 15:07'!basicPolygonsIndices"Indizes der Punkte in den Polygonen.Die 20 Punkte liegen am Rand eines Quadrates.Punkt 1 liegt rechts am Quadrat unterhalb der Mitte.Die Nummerierung der Punkte ist im Gegenuhrzeigersinn.Die Reihenfoge der Polygone ist wie bei Stan Wagon""Anmerkung: { 1.2.3 } ist #(1.2 3) und nicht #( 1 2 3)"	| result pol |		result := OrderedCollection new: 5.	"1"		pol := ETilePolygonRoassal new.	pol 		pointsIndices: { 1 . 2 . 6 . 7 };		innerLinesIndices: { {1 . 7} . {2 . 6} }; 		outerLinesIndices: { {1 . 2} . {6 . 7} }.		result add: pol.		"2"		pol := ETilePolygonRoassal new.	pol 		pointsIndices: { 13 . 14 . 15 };		innerLinesIndices: { {13 . 15} }; 		outerLinesIndices: { {13 . 14} . {14 . 15} }.	result add: pol.		"3"		pol := ETilePolygonRoassal new.	pol 		pointsIndices: { 18 . 19 . 20 };		innerLinesIndices: { {18 . 20} }; 		outerLinesIndices: { {18 . 19} . {19 . 20} }.	result add: pol.		"4"		pol := ETilePolygonRoassal new.	pol 		pointsIndices: { 3 . 4 . 5 . 11 . 12 };		innerLinesIndices: { {3 . 12} . {5 . 11} }; 		outerLinesIndices: { {3 . 4} . {4 . 5} . {11 . 12} }.	result add: pol.		"5"		pol := ETilePolygonRoassal new.	pol 		pointsIndices: { 8 . 9 . 10 . 16 . 17 };		innerLinesIndices: { {8 . 17} . {10 . 16} }; 		outerLinesIndices: { {8 . 9} . {9 . 10} . {16 . 17} }.	result add: pol.	^ result asArray  ! !Object subclass: #ETilesCount2x2	instanceVariableNames: 'sqLen sqArea maxCases allCases'	classVariableNames: ''	package: 'Pedro1'!!ETilesCount2x2 commentStamp: 'PeterGraf 2/18/2024 10:59' prior: 0!Soll: 154!!ETilesCount2x2 methodsFor: 'initialization' stamp: 'PeterGraf 2/19/2024 11:32'!initialize	sqLen := 2.	sqArea := 2*2.	"0..7 for +1 +2 +3 +4 -1 -2 -3 -4"	maxCases := 8 ** sqArea.	allCases := ByteArray new: maxCases.	allCases atAllPut: 1.			! !!ETilesCount2x2 methodsFor: 'initialization' stamp: 'PeterGraf 2/19/2024 12:03'!prettyPrint: aIndex	| tuple |		tuple := self convertIndexToTuple: aIndex.	^ String streamContents: [ :stream |						stream nextPutAll: '#( '.			1 to: tuple size do: [ :i |								(tuple at: i) = 0 ifTrue: [ stream nextPutAll: '''+1'' '].				(tuple at: i) = 1 ifTrue: [ stream nextPutAll: '''+2'' '].				(tuple at: i) = 2 ifTrue: [ stream nextPutAll: '''+3'' '].				(tuple at: i) = 3 ifTrue: [ stream nextPutAll: '''+4'' '].				(tuple at: i) = 4 ifTrue: [ stream nextPutAll: '''-1'' '].				(tuple at: i) = 5 ifTrue: [ stream nextPutAll: '''-2'' '].				(tuple at: i) = 6 ifTrue: [ stream nextPutAll: '''-3'' '].				(tuple at: i) = 7 ifTrue: [ stream nextPutAll: '''-4'' '].							].			stream nextPutAll: ')'.		]		! !!ETilesCount2x2 methodsFor: 'initialization' stamp: 'PeterGraf 2/19/2024 11:49'!prettyPrintBackup: aIndex	| tuple |		tuple := self convertIndexToTuple: aIndex.	^ String streamContents: [ :stream |						stream nextPutAll: '#( '.			1 to: tuple size do: [ :i |								(tuple at: i) = 0 ifTrue: [ stream nextPutAll: '''+1'' '].				(tuple at: i) = 1 ifTrue: [ stream nextPutAll: '''+2'' '].				(tuple at: i) = 2 ifTrue: [ stream nextPutAll: '''+3'' '].				(tuple at: i) = 3 ifTrue: [ stream nextPutAll: '''+4'' '].				(tuple at: i) = 4 ifTrue: [ stream nextPutAll: '''-1'' '].				(tuple at: i) = 5 ifTrue: [ stream nextPutAll: '''-2'' '].				(tuple at: i) = 6 ifTrue: [ stream nextPutAll: '''-3'' '].				(tuple at: i) = 7 ifTrue: [ stream nextPutAll: '''-4'' '].							].			stream nextPutAll: ')'.		]		! !!ETilesCount2x2 methodsFor: 'initialization' stamp: 'PeterGraf 2/19/2024 12:03'!prettyPrintBackup2: aIndex	| tuple |		tuple := self convertIndexToTuple: aIndex.	^ String streamContents: [ :stream |						stream nextPutAll: '#( '.			1 to: tuple size do: [ :i |								(tuple at: i) = 0 ifTrue: [ stream nextPutAll: '''+1'' '].				(tuple at: i) = 1 ifTrue: [ stream nextPutAll: '''+2'' '].				(tuple at: i) = 2 ifTrue: [ stream nextPutAll: '''+3'' '].				(tuple at: i) = 3 ifTrue: [ stream nextPutAll: '''+4'' '].				(tuple at: i) = 4 ifTrue: [ stream nextPutAll: '''-4'' '].				(tuple at: i) = 5 ifTrue: [ stream nextPutAll: '''-3'' '].				(tuple at: i) = 6 ifTrue: [ stream nextPutAll: '''-2'' '].				(tuple at: i) = 7 ifTrue: [ stream nextPutAll: '''-1'' '].							].			stream nextPutAll: ')'.		]		! !!ETilesCount2x2 methodsFor: 'accessing' stamp: 'PeterGraf 2/29/2024 07:22'!count"ETilesCount2x2 run"	| k |	1 to: allCases size do: [ :i |		(allCases at: i) ~= 0 ifTrue: [			| curTuple |			allCases byteAt: i put: 0. "temporär"			curTuple := self convertIndexToTuple: i.				"i ~= (self convertTupleToIndex: curTuple) ifTrue: [ self halt ]."					"i < 20 ifTrue: [ Transcript cr ]."			self deleteCaseIndex: i.			"Sonst bleibt nichts übrig"			"captain"			allCases byteAt: i put: 1.	]].""	k := 0.	1 to: allCases size - 1 do: [ :i |		(allCases at: i) ~= 0 ifTrue: [			k := k + 1.			Transcript 				show: '"'; show: k asString; show: '"';				space; 				show: '"'; show: i asString; show: '"';				space; 				show: (self prettyPrint: i); cr	]].""			^	allCases count: [ :val | val ~= 0 ]! !!ETilesCount2x2 methodsFor: 'as yet unclassified' stamp: 'PeterGraf 2/18/2024 22:52'!tupleForRotLeft180: aTuple"0..7 for +1 +2 +3 +4 -1 -2 -3 -4""Beim Rotieren verändert sich die Position und die Drehung."	| result |	result := Array new: sqArea.	result at: 1 put: (aTuple at: 4) + 2.	result at: 2 put: (aTuple at: 3) + 2.	result at: 3 put: (aTuple at: 2) + 2.	result at: 4 put: (aTuple at: 1) + 2.	result replaceAll: 4 with: 0.	result replaceAll: 5 with: 1.	result replaceAll: 8 with: 4.	result replaceAll: 9 with: 5.	self checkTuple: result.	^	result	! !!ETilesCount2x2 methodsFor: 'as yet unclassified' stamp: 'PeterGraf 2/18/2024 22:50'!tupleForHorizontalFlip: aTuple"0..7 for +1 +2 +3 +4 -1 -2 -3 -4""Beim Flip verändert sich die Position und das 'Vorzeichen'."	| result |	result := Array new: sqArea.	result at: 1 put: (aTuple at: 3).	result at: 2 put: (aTuple at: 4).	result at: 3 put: (aTuple at: 1).	result at: 4 put: (aTuple at: 2).	1 to: sqArea do: [ :i |		| val |		val := result at: i.		result at: i put: ( val <= 3 ifTrue: [ val + 4 ] ifFalse: [ val - 4] ) ].	self checkTuple: result.		^	result	! !!ETilesCount2x2 methodsFor: 'as yet unclassified' stamp: 'PeterGraf 2/19/2024 15:18'!checkPerm: aPerm	aPerm asSortedCollection asArray = #(1 2 3 4) ifFalse: [ self halt ]	! !!ETilesCount2x2 methodsFor: 'as yet unclassified' stamp: 'PeterGraf 2/19/2024 15:04'!tupleCloneFor: aTuple withPerm: aPerm	| result |	self checkPerm: aPerm.	result := Array new: sqArea.	1 to: sqArea do: [ :i |				result at: i put: ( aTuple at: (aPerm at: i) ) ].	self checkTuple: result.	^	result! !!ETilesCount2x2 methodsFor: 'as yet unclassified' stamp: 'PeterGraf 2/19/2024 15:15'!checkPermBackup: aPerm	(aPerm includes: 1) ifFalse: [ self halt ].	(aPerm includes: 2) ifFalse: [ self halt ].	(aPerm includes: 3) ifFalse: [ self halt ].	(aPerm includes: 4) ifFalse: [ self halt ].	! !!ETilesCount2x2 methodsFor: 'as yet unclassified' stamp: 'PeterGraf 2/18/2024 22:51'!tupleForRotLeft90: aTuple"0..7 for +1 +2 +3 +4 -1 -2 -3 -4""Beim Rotieren verändert sich die Position und die Drehung."	| result |	result := Array new: sqArea.	result at: 1 put: (aTuple at: 2) + 1.	result at: 2 put: (aTuple at: 4) + 1.	result at: 3 put: (aTuple at: 1) + 1.	result at: 4 put: (aTuple at: 3) + 1.	result replaceAll: 4 with: 0.	result replaceAll: 8 with: 4.	self checkTuple: result.	^	result	! !!ETilesCount2x2 methodsFor: 'as yet unclassified' stamp: 'PeterGraf 2/18/2024 23:36'!tupleForRotLeft270: aTuple"0..7 for +1 +2 +3 +4 -1 -2 -3 -4""Beim Rotieren verändert sich die Position und die Drehung."	| result |	result := Array new: sqArea.	result at: 1 put: (aTuple at: 3) + 3.	result at: 2 put: (aTuple at: 1) + 3.	result at: 3 put: (aTuple at: 4) + 3.	result at: 4 put: (aTuple at: 2) + 3.	result replaceAll: 4 with: 0.	result replaceAll: 5 with: 1.	result replaceAll: 6 with: 2.	result replaceAll: 8 with: 4.	result replaceAll: 9 with: 5.	result replaceAll: 10 with: 6.	self checkTuple: result.	^	result	! !!ETilesCount2x2 methodsFor: 'as yet unclassified' stamp: 'PeterGraf 2/29/2024 07:23'!deleteCaseIndex: aIndex	| curTuple cloneTuple |	curTuple := self convertIndexToTuple: aIndex.		"Shift1 right"	cloneTuple := self tupleCloneFor: curTuple withPerm: #(2 1 4 3).	self deleteCloneTuple: cloneTuple.	"Shift1 down"	cloneTuple := self tupleCloneFor: curTuple withPerm: #(3 4 1 2).	self deleteCloneTuple: cloneTuple.	"Shift1 diagonal"	"cloneTuple := self tupleCloneFor: curTuple withPerm: #(4 3 2 1).	self deleteCloneTuple: cloneTuple."	"Horizontal flip"	cloneTuple := self tupleForHorizontalFlip: curTuple.	self deleteCloneTuple: cloneTuple.	"Rot left 90"	cloneTuple := self tupleForRotLeft90: curTuple.	self deleteCloneTuple: cloneTuple.	"Rot left 180"	cloneTuple := self tupleForRotLeft180: curTuple.	self deleteCloneTuple: cloneTuple.	"Rot left 270"	cloneTuple := self tupleForRotLeft270: curTuple.	self deleteCloneTuple: cloneTuple.! !!ETilesCount2x2 methodsFor: 'as yet unclassified' stamp: 'PeterGraf 2/19/2024 15:02'!convertIndexToTuple: index	| str tuple |	tuple := Array new: sqArea.		str := (index - 1) printStringBase: 8 nDigits: sqArea.	1 to: sqArea do: [ :i |				tuple at: i put: ((str at: i) asInteger - 48) ]. "'0' asInteger = 48"	self checkTuple: tuple.	^	tuple		! !!ETilesCount2x2 methodsFor: 'as yet unclassified' stamp: 'PeterGraf 2/19/2024 15:02'!convertTupleToIndex: aTuple"content: 0..sqArea-1"	| index |	self checkTuple: aTuple.	index := 0.		1 to: sqArea do: [ :i |				index := 8 * index + (aTuple at: i) ].	^	index + 1! !!ETilesCount2x2 methodsFor: 'as yet unclassified' stamp: 'PeterGraf 2/18/2024 22:40'!checkTuple: aTuple	aTuple do: [ :k |		k < 0 ifTrue: [ self halt ].			k > 7 ifTrue: [ self halt ].	]! !!ETilesCount2x2 methodsFor: 'as yet unclassified' stamp: 'PeterGraf 2/19/2024 15:11'!deleteCloneTuple: cloneTuple	| index |	index := self convertTupleToIndex: cloneTuple. 			(allCases byteAt: index) ~= 0 ifTrue: [ 		allCases byteAt: index put: 0.		self deleteCaseIndex: index ].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ETilesCount2x2 class	instanceVariableNames: ''!!ETilesCount2x2 class methodsFor: 'running' stamp: 'PeterGraf 2/19/2024 15:48'!run	Transcript show: 'start: '; show: Time now asString; cr.	Transcript show: (self new count); cr.		Transcript show: 'end:   '; show: Time now asString; cr.	! !Object subclass: #ETilesCount3x3	instanceVariableNames: 'sqLen sqArea maxCases allCases'	classVariableNames: ''	package: 'Pedro1'!!ETilesCount3x3 commentStamp: 'PeterGraf 2/19/2024 14:29' prior: 0!Soll?: 934144!!ETilesCount3x3 methodsFor: 'accessing' stamp: 'PeterGraf 2/29/2024 07:27'!count"ETilesCount3x3 run"	1 to: allCases size do: [ :i |		(allCases at: i) ~= 0 ifTrue: [			"| curTuple |			curTuple := self convertIndexToTuple: i.			i ~= (self convertTupleToIndex: curTuple) ifTrue: [ self halt ]."			allCases byteAt: i put: 0. "temporär"			self deleteCaseIndex: i.			"Sonst bleibt nichts übrig"			"captain"			allCases byteAt: i put: 1 ]]." Too many: 934144	k := 0.	1 to: allCases size - 1 do: [ :i |		(allCases at: i) ~= 0 ifTrue: [			k := k + 1.			Transcript				show: '§'; show: k asString; show: '§';				space;				show: '§'; show: i asString; show: '§';				space;				show: (self prettyPrint: i); cr	]]."	^	allCases count: [ :val | val ~= 0 ]		! !!ETilesCount3x3 methodsFor: 'initialization' stamp: 'PeterGraf 2/19/2024 12:38'!initialize	sqLen := 3.	sqArea := 3*3.	"0..7 for +1 +2 +3 +4 -1 -2 -3 -4"	maxCases := 8 ** sqArea.	allCases := ByteArray new: maxCases.	allCases atAllPut: 1.			! !!ETilesCount3x3 methodsFor: 'initialization' stamp: 'PeterGraf 2/19/2024 12:03'!prettyPrint: aIndex	| tuple |		tuple := self convertIndexToTuple: aIndex.	^ String streamContents: [ :stream |						stream nextPutAll: '#( '.			1 to: tuple size do: [ :i |								(tuple at: i) = 0 ifTrue: [ stream nextPutAll: '''+1'' '].				(tuple at: i) = 1 ifTrue: [ stream nextPutAll: '''+2'' '].				(tuple at: i) = 2 ifTrue: [ stream nextPutAll: '''+3'' '].				(tuple at: i) = 3 ifTrue: [ stream nextPutAll: '''+4'' '].				(tuple at: i) = 4 ifTrue: [ stream nextPutAll: '''-1'' '].				(tuple at: i) = 5 ifTrue: [ stream nextPutAll: '''-2'' '].				(tuple at: i) = 6 ifTrue: [ stream nextPutAll: '''-3'' '].				(tuple at: i) = 7 ifTrue: [ stream nextPutAll: '''-4'' '].							].			stream nextPutAll: ')'.		]		! !!ETilesCount3x3 methodsFor: 'initialization' stamp: 'PeterGraf 2/19/2024 11:49'!prettyPrintBackup: aIndex	| tuple |		tuple := self convertIndexToTuple: aIndex.	^ String streamContents: [ :stream |						stream nextPutAll: '#( '.			1 to: tuple size do: [ :i |								(tuple at: i) = 0 ifTrue: [ stream nextPutAll: '''+1'' '].				(tuple at: i) = 1 ifTrue: [ stream nextPutAll: '''+2'' '].				(tuple at: i) = 2 ifTrue: [ stream nextPutAll: '''+3'' '].				(tuple at: i) = 3 ifTrue: [ stream nextPutAll: '''+4'' '].				(tuple at: i) = 4 ifTrue: [ stream nextPutAll: '''-1'' '].				(tuple at: i) = 5 ifTrue: [ stream nextPutAll: '''-2'' '].				(tuple at: i) = 6 ifTrue: [ stream nextPutAll: '''-3'' '].				(tuple at: i) = 7 ifTrue: [ stream nextPutAll: '''-4'' '].							].			stream nextPutAll: ')'.		]		! !!ETilesCount3x3 methodsFor: 'initialization' stamp: 'PeterGraf 2/19/2024 12:03'!prettyPrintBackup2: aIndex	| tuple |		tuple := self convertIndexToTuple: aIndex.	^ String streamContents: [ :stream |						stream nextPutAll: '#( '.			1 to: tuple size do: [ :i |								(tuple at: i) = 0 ifTrue: [ stream nextPutAll: '''+1'' '].				(tuple at: i) = 1 ifTrue: [ stream nextPutAll: '''+2'' '].				(tuple at: i) = 2 ifTrue: [ stream nextPutAll: '''+3'' '].				(tuple at: i) = 3 ifTrue: [ stream nextPutAll: '''+4'' '].				(tuple at: i) = 4 ifTrue: [ stream nextPutAll: '''-4'' '].				(tuple at: i) = 5 ifTrue: [ stream nextPutAll: '''-3'' '].				(tuple at: i) = 6 ifTrue: [ stream nextPutAll: '''-2'' '].				(tuple at: i) = 7 ifTrue: [ stream nextPutAll: '''-1'' '].							].			stream nextPutAll: ')'.		]		! !!ETilesCount3x3 methodsFor: 'as yet unclassified' stamp: 'PeterGraf 2/29/2024 19:45'!tupleForRotLeft180: aTuple"0..7 for +1 +2 +3 +4 -1 -2 -3 -4""Beim Rotieren verändert sich die Position und die Drehung.""1 2 3   9 8 7 4 5 6   6 5 47 8 9   3 2 1"	| result |	result := Array new: sqArea.	result at: 1 put: (aTuple at: 9) + 2.	result at: 2 put: (aTuple at: 8) + 2.	result at: 3 put: (aTuple at: 7) + 2.	result at: 4 put: (aTuple at: 6) + 2.	result at: 5 put: (aTuple at: 5) + 2.	result at: 6 put: (aTuple at: 4) + 2.	result at: 7 put: (aTuple at: 3) + 2.	result at: 8 put: (aTuple at: 2) + 2.	result at: 9 put: (aTuple at: 1) + 2.	result replaceAll: 4 with: 0.	result replaceAll: 5 with: 1.	result replaceAll: 8 with: 4.	result replaceAll: 9 with: 5.	"self checkTuple: result."	^	result	! !!ETilesCount3x3 methodsFor: 'as yet unclassified' stamp: 'PeterGraf 3/2/2024 12:53'!tupleForHorizontalFlip: aTuple"0..7 for +1 +2 +3 +4 -1 -2 -3 -4""Beim Flip verändert sich die Position und das 'Vorzeichen'.""1 2 3   7 8 9 4 5 6   4 5 67 8 9   1 2 3"	| result |	result := Array new: sqArea.	result at: 1 put: (aTuple at: 7).	result at: 2 put: (aTuple at: 8).	result at: 3 put: (aTuple at: 9).	result at: 4 put: (aTuple at: 4).	result at: 5 put: (aTuple at: 5).	result at: 6 put: (aTuple at: 6).	result at: 7 put: (aTuple at: 1).	result at: 8 put: (aTuple at: 2).	result at: 9 put: (aTuple at: 3).	"Vorzeichen ändern"	1 to: sqArea do: [ :i |		| val |		val := result at: i.		result at: i put: ( val <= 3 ifTrue: [ val + 4 ] ifFalse: [ val - 4] ) ].	"self checkTuple: result."		^	result	! !!ETilesCount3x3 methodsFor: 'as yet unclassified' stamp: 'PeterGraf 2/19/2024 15:20'!checkPerm: aPerm	aPerm asSortedCollection asArray = #(1 2 3 4 5 6 7 8 9) ifFalse: [ self halt ]! !!ETilesCount3x3 methodsFor: 'as yet unclassified' stamp: 'PeterGraf 2/19/2024 15:08'!tupleCloneFor: aTuple withPerm: aPerm	| result |	"self checkPerm: aPerm."	result := Array new: sqArea.	1 to: sqArea do: [ :i |				result at: i put: ( aTuple at: (aPerm at: i) ) ].	"self checkTuple: result."	^	result! !!ETilesCount3x3 methodsFor: 'as yet unclassified' stamp: 'PeterGraf 2/19/2024 15:19'!checkPermBackup: aPerm	(aPerm includes: 1) ifFalse: [ self halt ].	(aPerm includes: 2) ifFalse: [ self halt ].	(aPerm includes: 3) ifFalse: [ self halt ].	(aPerm includes: 4) ifFalse: [ self halt ].	(aPerm includes: 5) ifFalse: [ self halt ].	(aPerm includes: 6) ifFalse: [ self halt ].	(aPerm includes: 7) ifFalse: [ self halt ].	(aPerm includes: 8) ifFalse: [ self halt ].	(aPerm includes: 9) ifFalse: [ self halt ].	! !!ETilesCount3x3 methodsFor: 'as yet unclassified' stamp: 'PeterGraf 2/29/2024 19:44'!tupleForRotLeft90: aTuple"0..7 for +1 +2 +3 +4 -1 -2 -3 -4""Beim Rotieren verändert sich die Position und die Drehung.""1 2 3   3 6 9 4 5 6   2 5 87 8 9   1 4 7"	| result |	result := Array new: sqArea.	result at: 1 put: (aTuple at: 3) + 1.	result at: 2 put: (aTuple at: 6) + 1.	result at: 3 put: (aTuple at: 9) + 1.	result at: 4 put: (aTuple at: 2) + 1.	result at: 5 put: (aTuple at: 5) + 1.	result at: 6 put: (aTuple at: 8) + 1.	result at: 7 put: (aTuple at: 1) + 1.	result at: 8 put: (aTuple at: 4) + 1.	result at: 9 put: (aTuple at: 7) + 1.	result replaceAll: 4 with: 0.	result replaceAll: 8 with: 4.	"self checkTuple: result."	^	result	! !!ETilesCount3x3 methodsFor: 'as yet unclassified' stamp: 'PeterGraf 2/29/2024 19:47'!tupleForRotLeft270: aTuple"0..7 for +1 +2 +3 +4 -1 -2 -3 -4""Beim Rotieren verändert sich die Position und die Drehung.""1 2 3   7 4 1 4 5 6   8 5 27 8 9   9 6 3"	| result |	result := Array new: sqArea.	result at: 1 put: (aTuple at: 7) + 3.	result at: 2 put: (aTuple at: 4) + 3.	result at: 3 put: (aTuple at: 1) + 3.	result at: 4 put: (aTuple at: 8) + 3.	result at: 5 put: (aTuple at: 5) + 3.	result at: 6 put: (aTuple at: 2) + 3.	result at: 7 put: (aTuple at: 9) + 3.	result at: 8 put: (aTuple at: 6) + 3.	result at: 9 put: (aTuple at: 3) + 3.	result replaceAll: 4 with: 0.	result replaceAll: 5 with: 1.	result replaceAll: 6 with: 2.	result replaceAll: 8 with: 4.	result replaceAll: 9 with: 5.	result replaceAll: 10 with: 6.	"self checkTuple: result."	^	result	! !!ETilesCount3x3 methodsFor: 'as yet unclassified' stamp: 'PeterGraf 2/29/2024 19:50'!deleteCaseIndex: aIndex	| curTuple cloneTuple |	curTuple := self convertIndexToTuple: aIndex.	"Shift1 right"                                        "1 2 3 4 5 6 7 8 9"	cloneTuple := self tupleCloneFor: curTuple withPerm: #(2 3 1 5 6 4 8 9 7).	self deleteCloneTuple: cloneTuple.	"Shift2 right"                                        "1 2 3 4 5 6 7 8 9"	cloneTuple := self tupleCloneFor: curTuple withPerm: #(3 1 2 6 4 5 9 7 8).	self deleteCloneTuple: cloneTuple.	"Shift1 down"                                         "1 2 3 4 5 6 7 8 9"	cloneTuple := self tupleCloneFor: curTuple withPerm: #(4 5 6 7 8 9 1 2 3).	self deleteCloneTuple: cloneTuple.	"Shift2 down"                                         "1 2 3 4 5 6 7 8 9"	cloneTuple := self tupleCloneFor: curTuple withPerm: #(7 8 9 1 2 3 4 5 6).	self deleteCloneTuple: cloneTuple.	"Shift1 diagonal up right"                            "1 2 3 4 5 6 7 8 9"	cloneTuple := self tupleCloneFor: curTuple withPerm: #(8 9 7 2 3 1 5 6 4).	self deleteCloneTuple: cloneTuple.	"Shift2 diagonal up right"                            "1 2 3 4 5 6 7 8 9"	cloneTuple := self tupleCloneFor: curTuple withPerm: #(6 4 5 9 7 8 3 1 2).	self deleteCloneTuple: cloneTuple.	"Shift1 diagonal up left"                             "1 2 3 4 5 6 7 8 9"	cloneTuple := self tupleCloneFor: curTuple withPerm: #(9 7 8 3 1 2 6 4 5).	self deleteCloneTuple: cloneTuple.	"Shift2 diagonal up left"                             "1 2 3 4 5 6 7 8 9"	cloneTuple := self tupleCloneFor: curTuple withPerm: #(5 6 4 8 9 7 2 3 1).	self deleteCloneTuple: cloneTuple.	"Horizontal flip"	cloneTuple := self tupleForHorizontalFlip: curTuple.	self deleteCloneTuple: cloneTuple.	"Rot left 90"	cloneTuple := self tupleForRotLeft90: curTuple.	self deleteCloneTuple: cloneTuple.	"Rot left 180"	cloneTuple := self tupleForRotLeft180: curTuple.	self deleteCloneTuple: cloneTuple.	"Rot left 270"	cloneTuple := self tupleForRotLeft270: curTuple.	self deleteCloneTuple: cloneTuple.! !!ETilesCount3x3 methodsFor: 'as yet unclassified' stamp: 'PeterGraf 2/19/2024 14:32'!convertIndexToTuple: index	| str tuple |	tuple := Array new: sqArea.	str := (index - 1) printStringBase: 8 nDigits: sqArea.	1 to: sqArea do: [ :i |				tuple at: i put: ((str at: i) asInteger - 48) ]. "'0' asInteger = 48"	"self checkTuple: tuple."	^	tuple		! !!ETilesCount3x3 methodsFor: 'as yet unclassified' stamp: 'PeterGraf 2/19/2024 14:02'!convertTupleToIndex: aTuple"content: 0..sqArea-1"	| index |	"self checkTuple: aTuple."	index := 0.		1 to: sqArea do: [ :i |				index := 8 * index + (aTuple at: i) ].	"index isZero ifTrue: [ self halt ]."	^	index + 1! !!ETilesCount3x3 methodsFor: 'as yet unclassified' stamp: 'PeterGraf 2/18/2024 22:40'!checkTuple: aTuple	aTuple do: [ :k |		k < 0 ifTrue: [ self halt ].		k > 7 ifTrue: [ self halt ].	]! !!ETilesCount3x3 methodsFor: 'as yet unclassified' stamp: 'PeterGraf 2/19/2024 15:07'!deleteCloneTuple: cloneTuple	| index |	index := self convertTupleToIndex: cloneTuple.		(allCases byteAt: index) ~= 0 ifTrue: [		allCases byteAt: index put: 0.		self deleteCaseIndex: index ].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ETilesCount3x3 class	instanceVariableNames: ''!!ETilesCount3x3 class methodsFor: 'running' stamp: 'PeterGraf 2/19/2024 15:48'!run	Transcript show: 'start: '; show: Time now asString; cr.	Transcript show: (self new count); cr.		Transcript show: 'end:   '; show: Time now asString; cr.	! !